@GenModel(
	generateModelWizard="false", 
	generateExampleClass="false"
)

package ch.hilbri.assist.mapping.model.result

import ch.hilbri.assist.mapping.model.Application
import ch.hilbri.assist.mapping.model.AssistModel
import ch.hilbri.assist.mapping.model.Board
import ch.hilbri.assist.mapping.model.Box
import ch.hilbri.assist.mapping.model.Compartment
import ch.hilbri.assist.mapping.model.Core
import ch.hilbri.assist.mapping.model.Processor
import ch.hilbri.assist.mapping.model.Task
import java.util.List
import java.util.HashMap
 				

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

type Task2CoreMapType wraps HashMap<Task, Core>
type StringList wraps List<String>

interface Comparable wraps Comparable<Result>{}

// Hack to get a Map in Xcore
// https://stackoverflow.com/questions/41387196/how-to-define-a-map-in-xcore
class MetricScorePair wraps java.util.Map$Entry {
    refers AbstractMetric key
    Double value
}

class Result extends Comparable {
	String								name
	int									index
	refers AssistModel					model	
 	Task2CoreMapType					task2CoreMap
 	contains MetricScorePair[]			metricAbsoluteScoresMap 
 	contains MetricScorePair[]			metricScaledScoresMap
 	boolean 							partialSolution = "false"
	
	derived double absoluteTotalScore get {
		if (metricAbsoluteScoresMap.keySet.empty) 
			0.0
		else 
			metricAbsoluteScoresMap.values.reduce[p1, p2|p1+p2]
	}

	derived double scaledTotalScore get {
		if (metricScaledScoresMap.keySet.empty) 
			0.0
		else 
			metricScaledScoresMap.values.reduce[p1, p2|p1+p2]
	}

	op Task[] getMappedTasksForCore(Core core) {
		task2CoreMap.keySet.filter[task2CoreMap.get(it) == core].toEList
	}
	
	op int getCoreUtilization(Core core) {
		val taskList = getMappedTasksForCore(core)
		if (!taskList.isNullOrEmpty) 
			taskList.map[it.coreUtilization].reduce[p1, p2|p1 + p2]
		else
			0
	}


	/* This creates the list of mapping elements; each elements contains all hardware / software elements */
	op SingleMappingElement[]			getMappingElements() {
		task2CoreMap.entrySet.map[ 

			/* Retrieve the entries from the map */
			val application = key.eContainer as Application
			val task		= key
			val core		= value
			val processor 	= value.eContainer as Processor
			val board		= value.eContainer.eContainer as Board
			val box			= value.eContainer.eContainer.eContainer as Box
			val compartment = value.eContainer.eContainer.eContainer.eContainer as Compartment
			
			/* Create the SingleMappingElement based on that data */
			ResultFactory.eINSTANCE.createSingleMappingElement => [
				it.application 	= application
				it.task 		= task 
				it.core 		= core
				it.processor	= processor
				it.board		= board
				it.box			= box
				it.compartment	= compartment	
			]
			
		].toEList
	}
	
	op int compareTo(Result o) {
		Double.compare(o.scaledTotalScore, scaledTotalScore)
	}
}

class SingleMappingElement {
	refers 	Application		application
	refers 	Task			task
	refers 	Core			core
	refers	Processor		processor
	refers	Board			board
	refers 	Box				box
	refers	Compartment		compartment
}

abstract class AbstractMetric {
	String name
	boolean builtIn
	boolean higherScoreIsBetter
	int		weight
	
	op double computeAbsoluteScore(Result result)
}