@GenModel(
	generateModelWizard="false", 
	generateExampleClass="false"
)

package ch.hilbri.assist.mapping.model.result

import ch.hilbri.assist.model.Application
import ch.hilbri.assist.model.Board
import ch.hilbri.assist.model.Box
import ch.hilbri.assist.model.Compartment
import ch.hilbri.assist.model.Core
import ch.hilbri.assist.model.HardwareElement
import ch.hilbri.assist.model.Processor
import ch.hilbri.assist.model.Task
import java.util.HashMap
import java.util.List
 				

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

type Task2CoreMapType wraps HashMap<Task, Core>
type StringList wraps List<String>

interface Comparable wraps Comparable<Result>{}

// Hack to get a Map in Xcore
// https://stackoverflow.com/questions/41387196/how-to-define-a-map-in-xcore
class MetricScorePair wraps java.util.Map$Entry {
    refers AbstractMetric key
    Double value
}

class Result extends Comparable {
	String								name
	int									index
	refers ch.hilbri.assist.model.AssistModel		model	
 	Task2CoreMapType					task2CoreMap
 	contains MetricScorePair[]			metricAbsoluteScoresMap 
 	contains MetricScorePair[]			metricScaledScoresMap
 	boolean 							partialSolution = "false"
	
	derived double absoluteTotalScore get {
		if (metricAbsoluteScoresMap.keySet.empty) 
			0.0
		else 
			metricAbsoluteScoresMap.values.reduce[p1, p2|p1+p2]
	}

	derived double scaledTotalScore get {
		if (metricScaledScoresMap.keySet.empty) 
			0.0
		else 
			metricScaledScoresMap.values.reduce[p1, p2|p1+p2]
	}

	op Task[] getMappedTasksForCore(Core core) {
		task2CoreMap.keySet.filter[task2CoreMap.get(it) == core].toEList
	}
	
	op int getAbsoluteCoreUtilization(Core core) {
		val taskList = getMappedTasksForCore(core)
		if (!taskList.isNullOrEmpty) 
			taskList.map[it.coreUtilization].reduce[p1, p2|p1 + p2]
		else
			0
	}
	
	op double getRelativeCoreUtilization(Core core) {
		if (core.capacity > 0)
			new Double(getAbsoluteCoreUtilization(core)) / new Double(core.capacity)
		else
			-1.0
	}
	
	/* Return the hardware element of the level level that the task task is being mapped to */
	op HardwareElement getHardwareElementForTask(Task task, int level) {
		if (level == 0) 
			task2CoreMap.get(task)
		else if (level == 1)
			task2CoreMap.get(task).processor 
		else if (level == 2)
			task2CoreMap.get(task).processor.board
		else if (level == 3)
			task2CoreMap.get(task).processor.board.box
		else if (level == 4)
			task2CoreMap.get(task).processor.board.box.compartment
		else
			null
	}


	/* This creates the list of mapping elements; each elements contains all hardware / software elements */
	op SingleMappingElement[]			getMappingElements() {
		task2CoreMap.entrySet.map[ 

			/* Retrieve the entries from the map */
			val application = key.eContainer as Application
			val task		= key
			val core		= value
			val processor 	= value.eContainer as Processor
			val board		= value.eContainer.eContainer as Board
			val box			= value.eContainer.eContainer.eContainer as Box
			val compartment = value.eContainer.eContainer.eContainer.eContainer as Compartment
			
			/* Create the SingleMappingElement based on that data */
			ResultFactory.eINSTANCE.createSingleMappingElement => [
				it.application 	= application
				it.task 		= task 
				it.core 		= core
				it.processor	= processor
				it.board		= board
				it.box			= box
				it.compartment	= compartment	
			]
			
		].toEList
	}
	
	op int compareTo(Result o) {
		Double.compare(o.scaledTotalScore, scaledTotalScore)
	}
	
	op String toString() {
		val sb = new StringBuilder
		sb.append("Result        : " + name + " (" + index + ")\n")
		sb.append("Absolute Score: " + absoluteTotalScore + "\n")
		sb.append("Relative Score: " + scaledTotalScore + "\n")
		for (task : model.allTasks) {
			sb.append(task.fullName + "\t->\t" + task2CoreMap.get(task).fullName + '\n')
		}
		sb.toString
	}
}

class SingleMappingElement {
	refers 	Application		application
	refers 	Task			task
	refers 	Core			core
	refers	Processor		processor
	refers	Board			board
	refers 	Box				box
	refers	Compartment		compartment
}

abstract class AbstractMetric {
	String name
	boolean builtIn
	boolean higherScoreIsBetter
	int		weight
	
	op double computeAbsoluteScore(Result result)
}