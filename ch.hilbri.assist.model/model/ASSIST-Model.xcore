@GenModel(
    modelPluginID="ch.hilbri.assist.model",
    editPluginID="ch.hilbri.assist.model.edit",
    editDirectory="/ch.hilbri.assist.model.edit/src",
    editorPluginID="ch.hilbri.assist.model.editor", 
    editorDirectory="/ch.hilbri.assist.model.editor/src",
    generateModelWizard="false", 
    generateExampleClass="false"
)

package ch.hilbri.assist.model

import java.util.HashMap
import java.util.List
import java.lang.StringBuilder
import org.eclipse.emf.common.util.EList

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

class AssistModel {
    String           systemName          = ""
    int              minHypPeriodLength  = "-1"
    int              taskSwitchDelay     = "0"
    
    contains         Compartment[1..*]                 compartments
    
    contains         Application[1..*]                 applications
    
    contains         DislocalityRelation[0..*]         dislocalityRelations
    contains         ColocalityRelation[0..*]          colocalityRelations
    contains         DissimilarityRelation[0..*]       dissimilarityRelations
    
    contains         SchedulingRestriction[0..*]       schedulingRestrictions
    
    contains         ApplicationAlternatives[0..*]     applicationAlternatives
    contains         RestrictionAlternatives[0..*]     restrictionAlternatives
    contains         ExplorationCandidate[0..*]        explorationCandidates

    op Compartment[] getAllCompartments()     { compartments                                          }
    op Box[]         getAllBoxes()            { compartments.map[allBoxes].flatten.toEList            }
    op Board[]       getAllBoards()           { compartments.map[allBoards].flatten.toEList           }
    op Processor[]   getAllProcessors()       { compartments.map[allProcessors].flatten.toEList       }
    op Core[]        getAllCores()            { compartments.map[allCores].flatten.toEList            }
    op Task[]        getAllTasks()            { applications.map[tasks].flatten.toEList               }
    
    op HardwareElement[] getAllHardwareElements(int level) {
        if (level == 0)         allCores.map[it as HardwareElement]
        else if (level == 1)    allProcessors.map[it as HardwareElement]
        else if (level == 2)    allBoards.map[it as HardwareElement]
        else if (level == 3)    allBoxes.map[it as HardwareElement]
        else if (level == 4)    allCompartments.map[it as HardwareElement] 
        else                    null
    }
    
    op HardwareElement[] getAllHardwareElements() {
        val iterables = allCompartments.map[it as HardwareElement] +
                        allBoxes.map[it as HardwareElement] +
                        allBoards.map[it as HardwareElement] +  
                        allProcessors.map[it as HardwareElement] + 
                        allCores.map[it as HardwareElement]
        return iterables.toEList
    }
}

// 
// PROPERTIES
//
class Property {
}

class StringProperty extends Property {
    String value = ""
}

class IntProperty extends Property {
    int value = "0"
}

class ManufacturerProperty extends StringProperty {
}

class PowerSupplyProperty extends StringProperty {
}

class BoardTypeProperty extends StringProperty {
}

class ProcessorTypeProperty extends StringProperty {
}

class RAMCapacityProperty extends IntProperty {
}

class ROMCapacityProperty extends IntProperty {
}

class CoreCapacityProperty extends IntProperty {
}

class CoreArchitectureProperty extends StringProperty {
}

class DesignAssuranceLevelProperty extends Property {
    DesignAssuranceLevelType value = "None"
}

class CustomIntProperty extends IntProperty {
    String name = ""
}

class CustomStringProperty extends StringProperty {
    String name = ""
}

//
// HARDWARE ELEMENTS
//
class CustomProperty{}

class HardwareElement {
    String                        name              = ""
    contains Property[0..*]       properties
    contains CustomProperty[0..*] customProperties
    contains Feature[0..*]        features
    
    op String getManufacturer() {
        val manufacturerProperties = properties.filter[it instanceof ManufacturerProperty]
        if (!manufacturerProperties.isNullOrEmpty) return (manufacturerProperties.head as ManufacturerProperty).value
        else return null
    }
    
    derived HardwareArchitectureLevelType getHardwareLevel get {
        if (this instanceof Compartment) HardwareArchitectureLevelType.COMPARTMENT
        else if (this instanceof Box) HardwareArchitectureLevelType.BOX
        else if (this instanceof Board) HardwareArchitectureLevelType.BOARD
        else if (this instanceof Processor) HardwareArchitectureLevelType.PROCESSOR
        else if (this instanceof Core) HardwareArchitectureLevelType.CORE
    }
}

class Feature {
    String   name                    = ""
    int      units                   = "-1"
    boolean  synchronizedAccess      = "false"
    boolean  shared                  = "false"  
    derived boolean isExclusive get { !isShared  }
}

class Compartment extends HardwareElement {
    contains Box[1..*] boxes opposite compartment
    
    derived String fullName get { name }
        
    op Box[]             getAllBoxes()         { boxes                                        }
    op Board[]           getAllBoards()        { boxes.map[allBoards].flatten.toEList         }
    op Processor[]       getAllProcessors()    { boxes.map[allProcessors].flatten.toEList     }
    op Core[]            getAllCores()         { boxes.map[allCores].flatten.toEList          }
    
    op String getPowerSupply() {
        val powerSupplyProperties = properties.filter[it instanceof PowerSupplyProperty]
        if (!powerSupplyProperties.isNullOrEmpty) return (powerSupplyProperties.head as PowerSupplyProperty).value
        else return null
    }
}


class Box extends HardwareElement {
    container     Compartment compartment opposite boxes
    
    contains     Board[0..*] boards opposite box
    contains     BoardAlternatives[0..*] boardAlternatives
    
    derived String fullName get { compartment.fullName + "." + name }
    
    op Board[]     getAllBoards()         { boards                                        }
    op Processor[] getAllProcessors()     { boards.map[allProcessors].flatten.toEList     }
    op Core[]      getAllCores()          { boards.map[allCores].flatten.toEList          }
}

class BoardAlternatives {  // XOR
    contains BoardAlternative[0..*] alternatives
}

class BoardAlternative {
    String name    = ""
    contains Board[0..*] boards 
}

class Board extends HardwareElement {
    String                             boardType       = ""
    String                             powerSupply     = ""
    DesignAssuranceLevelType           assuranceLevel  = "None"
    int                                ramCapacity     = "0"
    int                                romCapacity     = "0"
    
    container    Box                   box             opposite boards
    contains     Processor[1..*]       processors      opposite board
    
    derived String fullName get { if (box !== null) box.fullName + "." + name else name}
    
    op String            toString()            { name                                     }
    op Processor[]       getAllProcessors()    { processors                               }
    op Core[]            getAllCores()         { processors.map[allCores].flatten.toEList }
}

class Processor extends HardwareElement {
    String processorType = ""
    derived String fullName get { board.fullName + "." + name }
    container Board board opposite processors
    contains Core[1..*] cores opposite processor
    op Core[] getAllCores() { cores }
}

class Core extends HardwareElement {
    String architecture = ""
    int capacity         = "0"
    derived String fullName get { processor.fullName + "." + name }
    container Processor processor opposite cores
}

class ApplicationAlternatives {  // XOR
    contains ApplicationAlternative[0..*] alternatives
}

class ApplicationAlternative {
    String name
    contains Application[0..*] applications
}

class SoftwareElement {
	String name = ""
	op String toString() { getName }
}

class Application extends SoftwareElement {
    String                          developedBy         = ""
    DesignAssuranceLevelType        criticalityLevel    = "None"
    
    contains Task[1..*]             tasks             opposite application
    contains CustomProperty[0..*]   customProperties
    
    refers HardwareElement[0..*] restrictMappingToHardwareElements
    
    derived String        fullName get { getName }
}

class Task extends SoftwareElement {    
    int coreUtilization                       = "0"
    int ramUtilization                        = "0"
    int romUtilization                        = "0"
    int duration                              = "-1"
    int period                                = "-1"
    int earlyTolerance                        = "-1"
    int lateTolerance                         = "-1"
    int maxStartTime                          = "-1"
    int maxEndTime                            = "-1"
    int addInitTime                           = "-1"
    int slices                                = "-1"
    int minSliceDuration                      = "-1"
    PeriodicityType periodicity               = "strict"
    Color color                               = "none"
    
    container Application application opposite tasks
    
    contains FeatureRequirement[0..*]        featureRequirements
    contains CustomProperty[0..*]            customProperties
    
    refers HardwareElement[0..*]             restrictMappingToHardwareElements
    refers Core[0..1]                        assignedCore
    
    derived String fullName get { application.getName + "." + getName }
}

class FeatureRequirement {
    String                          name            = ""
    HardwareArchitectureLevelType   hardwareLevel
    int                             units           = "-1"
    boolean                         shared          = "false"
    derived boolean isExclusive get { !isShared }
}

/* *********************************************** */
/*   MAPPING: RESTRICTIONS                         */
/* *********************************************** */
type ListOfTaskLists wraps EList<EList<Task>>

class MappingRelation{
    refers SoftwareElement[0..*] softwareElements
    HardwareArchitectureLevelType hardwareLevel
    
    derived ListOfTaskLists allTasks get {
    	val List<EList<Task>> list = newArrayList
    	for (se : softwareElements) {
    		if (se instanceof Application)
    			list.add(se.tasks)
    		if (se instanceof Task)
    			list.add(#[se].toEList)
    	}
    	return list.toEList
    }
    
    derived String softwareElementNames get {
    	val output = new StringBuilder()
    	for (se : softwareElements) {
    		if (se instanceof Application) 
    			output.append(se.getName)
    		if (se instanceof Task)
    			output.append(se.getName)
    		if (se != softwareElements.last)
    			output.append(", ")
    	}
    	return output.toString
    }
}

class DislocalityRelation   extends MappingRelation {}

class ColocalityRelation    extends MappingRelation {}

class DissimilarityRelation extends MappingRelation {
    contains DissimilarityClause[1] dissimilarityClause
}

class DissimilarityClause {}

// OR
class DissimilarityDisjunction extends DissimilarityClause {
    contains DissimilarityClause[2..*] dissimilarityClauses
}
// AND
class DissimilarityConjunction extends DissimilarityClause  {
    contains DissimilarityClause[2..*] dissimilarityClauses
}

// Basic Case
class DissimilarityEntry extends DissimilarityClause {
    DissimilarityAttributes dissimilarityAttribute
    derived HardwareArchitectureLevelType hardwareLevel get {
        switch (dissimilarityAttribute) {
            case COMPARTMENT_MANUFACTURER:  { return HardwareArchitectureLevelType.COMPARTMENT  }    
            case COMPARTMENT_POWERSUPPLY:   { return HardwareArchitectureLevelType.COMPARTMENT  }
            case BOX_MANUFACTURER:          { return HardwareArchitectureLevelType.BOX          }
            case BOARD_MANUFACTURER:        { return HardwareArchitectureLevelType.BOARD        }
            case BOARD_BOARDTYPE:           { return HardwareArchitectureLevelType.BOARD        }        
            case BOARD_POWERSUPPLY:         { return HardwareArchitectureLevelType.BOARD        }
            case BOARD_ASSURANCELEVEL:      { return HardwareArchitectureLevelType.BOARD        }
            case PROCESSOR_MANUFACTURER:    { return HardwareArchitectureLevelType.PROCESSOR    }
            case PROCESSOR_PROCESSORTYPE:   { return HardwareArchitectureLevelType.PROCESSOR    }
            case CORE_ARCHITECTURE:         { return HardwareArchitectureLevelType.CORE         }
        }
    }
}

enum DissimilarityAttributes {
    COMPARTMENT_MANUFACTURER    as "Compartment.Manufacturer"
    COMPARTMENT_POWERSUPPLY     as "Compartment.PowerSupply"
    BOX_MANUFACTURER            as "Box.Manufacturer"
    BOARD_MANUFACTURER          as "Board.Manufacturer"
    BOARD_BOARDTYPE             as "Board.Type"
    BOARD_POWERSUPPLY           as "Board.PowerSupply"
    BOARD_ASSURANCELEVEL        as "Board.DesignAssuranceLevel"
    PROCESSOR_MANUFACTURER      as "Processor.Manufacturer"
    PROCESSOR_PROCESSORTYPE     as "Processor.Type"
    CORE_ARCHITECTURE           as "Core.Architecture"
}

/* ********************************************** */
/* SCHEDULING: Restrictions                       */
/* ********************************************** */
class SchedulingRestriction {}

// Basic kinds of relations
class SimpleRelation extends SchedulingRestriction {
    refers Task[2..*] tasks
}

class ComplexRelation extends SchedulingRestriction {
    refers Task[1..*] tasks
    refers Task       otherTask
    int               delay    
}

// Concrete relations:
// Task1, Task2, ... start at the same time;
class RestrictionStartAtTheSameTime  extends SimpleRelation {}

// Task1, Task2, ... finish at the same time;
class RestrictionFinishAtTheSameTime extends SimpleRelation {}

// Task2 starts after Task1 has finished (with delay of min X);
// Task3, Task4, ...  start after Task1 has finished (with delay of min X);
class RestrictionStartAfterOtherFinished extends ComplexRelation {}

// Task2 starts after Task1 has started (with delay of min X);
// Task3, Task4, ...  start after Task1 has started (with delay of min X);
class RestrictionStartAfterOtherStarted extends ComplexRelation {}

// Task1, Task2, ... require disjoint execution;
class RestrictionDisjointExecution extends SimpleRelation {}


/* ********************************************** */
/* GENERAL ENUMS                                  */
/* ********************************************** */
    
enum HardwareArchitectureLevelType {
    CORE         as "Core"             = 0
    PROCESSOR    as "Processor"        = 1
    BOARD        as "Board"            = 2
    BOX          as "Box"              = 3
    COMPARTMENT  as "Compartment"      = 4
}

enum DesignAssuranceLevelType {
    NONE         as "None"             = 0
    QS           as "QS"               = 1
    D            as "D"                = 2
    C            as "C"                = 3
    B            as "B"                = 4
    A            as "A"                = 5
}

enum PeriodicityType {
    STRICT       as "strict"           = 0
    FLEXIBLE     as "flexible"         = 1
}

enum Color {
    NONE         as "none"             = -1
    BLACK        as "black"            = 0
    BLUE         as "blue"             = 1
    CYAN         as "cyan"             = 2
    GRAY         as "gray"             = 3
    GREEN        as "green"            = 4
    MAGENTA      as "magenta"          = 5
    RED          as "red"              = 6
    WHITE        as "white"            = 7
    YELLOW       as "yellow"           = 8 
    DARK_BLUE    as "darkblue"         = 9
    DARK_CYAN    as "darkcyan"         = 10
    DARK_GRAY    as "darkgray"         = 11
    DARK_GREEN   as "darkgreen"        = 12
    DARK_MAGENTA as "darkmagenta"      = 13
    DARK_RED     as "darkred"          = 14
    DARK_YELLOW  as "darkyellow"       = 15
}

/* ************************************** */
/* DESIGN SPACE EXPLORATION               */
/* ************************************** */
class RestrictionAlternatives {
    contains RestrictionAlternative[0..*] alternatives
}

class RestrictionAlternative{
    String name
    contains DislocalityRelation[0..*]      dislocalityRelations
    contains ColocalityRelation[0..*]       colocalityRelations
    contains DissimilarityRelation[0..*]    dissimilarityRelations
}

class ExplorationCandidate {
    String name
    refers BoardAlternative[0..*]           boardAlternatives
    refers ApplicationAlternative[0..*]     applicationAlternatives
    refers RestrictionAlternative[0..*]     restrictionAlternatives
}

class ExplorationResult {
    refers ExplorationCandidate candidate
    refers AssistModel model
    refers MappingResult mappingResult
    boolean feasible
    Double absoluteScore
    Double scaledScore
}

abstract class AbstractDSEMetric {
    String  name
    boolean builtIn
    boolean higherScoreIsBetter
    
    op double computeAbsoluteScore(ExplorationResult result)
}

/* **************************************
 * RESULTS - MAPPING
 * ************************************** */
type Task2CoreMapType wraps HashMap<Task, Core>
type StringList wraps List<String>

interface Comparable wraps Comparable<MappingResult>{}

// Hack to get a Map in Xcore
// https://stackoverflow.com/questions/41387196/how-to-define-a-map-in-xcore
class MetricScorePair wraps java.util.Map$Entry {
    refers AbstractMappingMetric key
    Double value
}

class MappingResult extends Comparable {
    String                             name
    int                                index
    Task2CoreMapType                   task2CoreMap
    refers   AssistModel               model    
    contains MetricScorePair[]         metricAbsoluteScoresMap 
    contains MetricScorePair[]         metricScaledScoresMap
    boolean                            partialSolution = "false"
    
    op boolean isUsed(Core core) {
    	return !getMappedTasksForCore(core).isNullOrEmpty
    }
    
    op boolean isUsed(Processor processor) {
    	return !processor.cores.filter[isUsed(it)].isNullOrEmpty
    }
    
    op boolean isUsed(Board board) {
    	return !board.processors.filter[isUsed(it)].isNullOrEmpty
    }
    
    op boolean isUsed(Box box) {
    	return !box.boards.filter[isUsed(it)].isNullOrEmpty
    }
    
    op boolean isUsed(Compartment compartment) {
    	return !compartment.boxes.filter[isUsed(it)].isNullOrEmpty
    }
    
    derived double absoluteTotalScore get {
        if (metricAbsoluteScoresMap.keySet.empty)     0.0
        else metricAbsoluteScoresMap.values.reduce[p1, p2|p1+p2]
    }

    derived double scaledTotalScore get {
        if (metricScaledScoresMap.keySet.empty)        0.0
        else metricScaledScoresMap.values.reduce[p1, p2|p1+p2]
    }

    op Task[] getMappedTasksForCore(Core core) {
        getTask2CoreMap.keySet.filter[getTask2CoreMap.get(it) == core].toEList
    }
    
    op int getAbsoluteCoreUtilization(Core core) {
        val taskList = getMappedTasksForCore(core)
        if (!taskList.isNullOrEmpty) taskList.map[it.coreUtilization].reduce[p1, p2|p1 + p2]
        else     0
    }
    
    op double getRelativeCoreUtilization(Core core) {
        if (core.capacity > 0) new Double(getAbsoluteCoreUtilization(core)) / new Double(core.capacity)
        else     -1.0
    }
    
    /* Return the hardware element of the level level that the task task is being mapped to */
    op HardwareElement getHardwareElementForTask(Task task, int level) {
        if (level == 0)         getTask2CoreMap.get(task)
        else if (level == 1)    getTask2CoreMap.get(task).processor 
        else if (level == 2)    getTask2CoreMap.get(task).processor.board
        else if (level == 3)    getTask2CoreMap.get(task).processor.board.box
        else if (level == 4)    getTask2CoreMap.get(task).processor.board.box.compartment
        else                     null
    }

    /* This creates the list of mapping elements; each elements contains all hardware / software elements */
    op SingleMappingElement[] getMappingElements() {
        getTask2CoreMap.entrySet.map[ 

            /* Retrieve the entries from the map */
            val application = key.eContainer as Application
            val task        = key
            val core        = value
            val processor     = value.eContainer as Processor
            val board        = value.eContainer.eContainer as Board
            val box            = value.eContainer.eContainer.eContainer as Box
            val compartment = value.eContainer.eContainer.eContainer.eContainer as Compartment
            
            /* Create the SingleMappingElement based on that data */
            ModelFactory.eINSTANCE.createSingleMappingElement => [
                it.application     = application
                it.task            = task 
                it.core            = core
                it.processor       = processor
                it.board           = board
                it.box             = box
                it.compartment     = compartment    
            ]
            
        ].toEList
    }
    
    op int compareTo(MappingResult o) {
        Double.compare(o.scaledTotalScore, scaledTotalScore)
    }
    
    op String toString() {
        val sb = new StringBuilder
        sb.append("Result        : " + getName + " (" + getIndex + ")\n")
        sb.append("Absolute Score: " + absoluteTotalScore + "\n")
        sb.append("Relative Score: " + scaledTotalScore + "\n")
        for (task : getModel.allTasks) {
            sb.append(task.fullName + "\t->\t" + getTask2CoreMap.get(task).fullName + '\n')
        }
        sb.toString
    }
}

class SingleMappingElement {
    refers    Application        application
    refers    Task               task
    refers    Core               core
    refers    Processor          processor
    refers    Board              board
    refers    Box                box
    refers    Compartment        compartment
}

abstract class AbstractMappingMetric {
    String  name
    boolean builtIn
    boolean higherScoreIsBetter
    int     weight
    
    op double computeAbsoluteScore(MappingResult result)
}

/* ************************************** 
 * RESULTS - SCHEDULING
 * ************************************* */
type Task2ExecutionInstancesMapType wraps HashMap<Task, List<TaskExecutionInstance>> 

class SchedulingResult {
    String                             name                      = ""
    int                                hyperPeriodLength         = "-1"
    refers AssistModel                 model
    Task2ExecutionInstancesMapType     schedule
}

class TaskExecutionInstance {
    int begin = "-1"
    int end   = "-1"
    op String toString()            { "[" + begin + ", " + end + "]" }
}