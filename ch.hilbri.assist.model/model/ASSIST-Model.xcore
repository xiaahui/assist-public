@GenModel(
    modelPluginID="ch.hilbri.assist.model",
    editPluginID="ch.hilbri.assist.model.edit",
    editDirectory="/ch.hilbri.assist.model.edit/src",
    editorPluginID="ch.hilbri.assist.model.editor", 
    editorDirectory="/ch.hilbri.assist.model.editor/src",
    generateModelWizard="false", 
    generateExampleClass="false"
)

package ch.hilbri.assist.model

import java.util.HashMap
import java.util.List
import java.lang.StringBuilder
import org.eclipse.emf.common.util.EList

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

// 
// PROPERTIES
//
class Property {}
class StringProperty                extends Property        { String                value = ""          }
class IntProperty                   extends Property        { int                   value = "0"         }
class SystemNameProperty            extends StringProperty  {}
class MinHypPeriodLengthProperty    extends IntProperty     {}
class TaskSwitchDelayProperty       extends IntProperty     {}
class ManufacturerProperty          extends StringProperty  {}
class PowerSupplyProperty           extends StringProperty  {}
class BoardTypeProperty             extends StringProperty  {}
class ProcessorTypeProperty         extends StringProperty  {}
class RAMCapacityProperty           extends IntProperty     {}
class RAMUtilizationProperty        extends IntProperty     {}
class ROMCapacityProperty           extends IntProperty     {}
class ROMUtilizationProperty        extends IntProperty     {}
class CoreCapacityProperty          extends IntProperty     {}
class CoreUtilizationProperty       extends IntProperty     {}
class CoreArchitectureProperty      extends StringProperty  {}
class DevelopedByProperty           extends StringProperty  {}
class DurationProperty              extends IntProperty     {}
class PeriodProperty                extends IntProperty     {}
class EarlyToleranceProperty        extends IntProperty     {}
class LateToleranceProperty         extends IntProperty     {}
class MaxStartTimeProperty          extends IntProperty     {}
class MaxEndTimeProperty            extends IntProperty     {}
class AddInitTimeProperty           extends IntProperty     {}
class SlicesProperty                extends IntProperty     {}
class MinSliceDurationProperty      extends IntProperty     {}
class DesignAssuranceLevelProperty  extends Property        { DesignAssuranceLevelType value = "None"       }
class CriticalityLevelProperty      extends Property        { DesignAssuranceLevelType value = "None"       }
class PeriodicityProperty           extends Property        { PeriodicityType          value = "strict"     }    
class ColorProperty                 extends Property        { Color                    value = "none"       }
class AssignedCoreProperty          extends Property        { refers Core[0..1]        value                }
class CustomProperty                extends Property        { String                   name = ""            }
class CustomIntProperty             extends CustomProperty  { int                      value = "0"          }
class CustomStringProperty          extends CustomProperty  { String                   value = ""           }

class AssistModel {
    contains         Property[0..*]                    properties
    contains         Compartment[0..*]                 compartments
    contains         Application[0..*]                 applications
    contains         ApplicationAlternative[0..*]      applicationAlternatives
    contains         DislocalityRelation[0..*]         dislocalityRelations
    contains         ColocalityRelation[0..*]          colocalityRelations
    contains         DissimilarityRelation[0..*]       dissimilarityRelations
    contains         SchedulingRestriction[0..*]       schedulingRestrictions
    contains         RestrictionAlternative[0..*]      restrictionAlternatives
    contains         ExplorationCandidate[0..*]        explorationCandidates

    op Compartment[] getAllCompartments()     { compartments                                          }
    op Box[]         getAllBoxes()            { compartments.map[allBoxes].flatten.toEList            }
    op Board[]       getAllBoards()           { compartments.map[allBoards].flatten.toEList           }
    op Processor[]   getAllProcessors()       { compartments.map[allProcessors].flatten.toEList       }
    op Core[]        getAllCores()            { compartments.map[allCores].flatten.toEList            }
    op Task[]        getAllTasks()            { applications.map[tasks].flatten.toEList               }
    
    op HardwareElement[] getAllHardwareElements(HardwareArchitectureLevelType level) {
        switch (level) {
            case CORE:          { getAllHardwareElements(0) }
            case PROCESSOR:     { getAllHardwareElements(1) }
            case BOARD:         { getAllHardwareElements(2) }
            case BOX:           { getAllHardwareElements(3) }
            case COMPARTMENT:   { getAllHardwareElements(4) }
        }
    }
    
    op HardwareElement[] getAllHardwareElements(int level) {
        if (level == 0)         allCores.map[it as HardwareElement]
        else if (level == 1)    allProcessors.map[it as HardwareElement]
        else if (level == 2)    allBoards.map[it as HardwareElement]
        else if (level == 3)    allBoxes.map[it as HardwareElement]
        else if (level == 4)    allCompartments.map[it as HardwareElement] 
        else                    null
    }
    
    op HardwareElement[] getAllHardwareElements() {
        val iterables = allCompartments.map[it as HardwareElement] +
                        allBoxes.map[it as HardwareElement] +
                        allBoards.map[it as HardwareElement] +  
                        allProcessors.map[it as HardwareElement] + 
                        allCores.map[it as HardwareElement]
        return iterables.toEList
    }
    
    // SystemName
    op String getSystemName() {
        if (!properties.filter[it instanceof SystemNameProperty].isNullOrEmpty) 
            (properties.filter[it instanceof SystemNameProperty].head as SystemNameProperty).value
        else 
            null
    }
    
    op void setSystemName(String newValue) {
        if (!properties.filter[it instanceof SystemNameProperty].isNullOrEmpty) 
            (properties.filter[it instanceof SystemNameProperty].head as SystemNameProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createSystemNameProperty => [value = newValue])
    }
    
    // MinHypPeriodLength
    op int getMinHypPeriodLength() {
        if (!properties.filter[it instanceof MinHypPeriodLengthProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MinHypPeriodLengthProperty].head as MinHypPeriodLengthProperty).value
        else 
            -1
    }
    
    op void setMinHypPeriodLength(int newValue) {
        if (!properties.filter[it instanceof MinHypPeriodLengthProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MinHypPeriodLengthProperty].head as MinHypPeriodLengthProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createMinHypPeriodLengthProperty => [value = newValue])
    }
    
    // TaskSwitchDelay
    op int getTaskSwitchDelay() {
        if (!properties.filter[it instanceof TaskSwitchDelayProperty].isNullOrEmpty) 
            (properties.filter[it instanceof TaskSwitchDelayProperty].head as TaskSwitchDelayProperty).value
        else 
            -1
    }
    
    op void setTaskSwitchDelay(int newValue) {
        if (!properties.filter[it instanceof TaskSwitchDelayProperty].isNullOrEmpty) 
            (properties.filter[it instanceof TaskSwitchDelayProperty].head as TaskSwitchDelayProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createTaskSwitchDelayProperty => [value = newValue])
    }
}


//
// HARDWARE ELEMENTS
//
class HardwareElement {
    String                        name              = ""
    contains Property[0..*]       properties
    contains Feature[0..*]        features
    
    op String getManufacturer() {
        if (!properties.filter[it instanceof ManufacturerProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ManufacturerProperty].head as ManufacturerProperty).value
        else 
            null
    }
    
    op void setManufacturer(String newValue) {
        if (!properties.filter[it instanceof ManufacturerProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ManufacturerProperty].head as ManufacturerProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createManufacturerProperty => [value = newValue])
    }
    
    derived HardwareArchitectureLevelType getHardwareLevel get {
        if (this instanceof Compartment) HardwareArchitectureLevelType.COMPARTMENT
        else if (this instanceof Box) HardwareArchitectureLevelType.BOX
        else if (this instanceof Board) HardwareArchitectureLevelType.BOARD
        else if (this instanceof Processor) HardwareArchitectureLevelType.PROCESSOR
        else if (this instanceof Core) HardwareArchitectureLevelType.CORE
    }
    
    op CustomProperty[] getCustomPropertiesWithName(String name) {
        properties.filter[it instanceof CustomProperty && (it as CustomProperty).name == name].map[it as CustomProperty].toEList
    }
    
    op CustomProperty[] getCustomPropertiesWithNameAndValue(String name, String value) {
        getCustomPropertiesWithName(name).filter[(it as CustomStringProperty).value == value].toEList
    }
    
    op String getCustomStringProperty(String name) {
        if (!getCustomPropertiesWithName(name).filter[it instanceof CustomStringProperty].isNullOrEmpty)
            (getCustomPropertiesWithName(name).filter[it instanceof CustomStringProperty].head as CustomStringProperty).value
        else 
            null
    }
    
    op int getCustomIntProperty(String name) {
        if (!getCustomPropertiesWithName(name).filter[it instanceof CustomIntProperty].isNullOrEmpty)
            (getCustomPropertiesWithName(name).filter[it instanceof CustomIntProperty].head as CustomIntProperty).value
        else 
            -1
    }
}

class Feature {
    String   name                    = ""
    int      units                   = "-1"
    boolean  synchronizedAccess      = "false"
    boolean  shared                  = "false"  
    derived boolean isExclusive get { !isShared  }
}

class Compartment extends HardwareElement {
    contains Box[1..*] boxes opposite compartment
    
    derived String fullName get { name }
    
    op Box[]             getAllBoxes()         { boxes                                        }
    op Board[]           getAllBoards()        { boxes.map[allBoards].flatten.toEList         }
    op Processor[]       getAllProcessors()    { boxes.map[allProcessors].flatten.toEList     }
    op Core[]            getAllCores()         { boxes.map[allCores].flatten.toEList          }

    op String getPowerSupply() {
        if (!properties.filter[it instanceof PowerSupplyProperty].isNullOrEmpty) 
            (properties.filter[it instanceof PowerSupplyProperty].head as PowerSupplyProperty).value
        else 
            null
    }
    
    op void setPowerSupply(String newValue) {
        if (!properties.filter[it instanceof PowerSupplyProperty].isNullOrEmpty) 
            (properties.filter[it instanceof PowerSupplyProperty].head as PowerSupplyProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createPowerSupplyProperty => [value = newValue])
    }
}


class Box extends HardwareElement {
    container    Compartment compartment opposite boxes
    contains     Board[0..*] boards opposite box
    contains     BoardAlternative[0..*] boardAlternatives
    
    derived String fullName get { compartment.fullName + "." + name }
    
    op Board[]     getAllBoards()         { boards                                        }
    op Processor[] getAllProcessors()     { boards.map[allProcessors].flatten.toEList     }
    op Core[]      getAllCores()          { boards.map[allCores].flatten.toEList          }
}

class BoardAlternative {
    String name    = ""
    contains Board[0..*] boards 
}

class Board extends HardwareElement {
    container    Box                   box             opposite boards
    contains     Processor[1..*]       processors      opposite board
    
    derived String fullName get { if (box !== null) box.fullName + "." + name else name}
    
    op String            toString()            { name                                     }
    op Processor[]       getAllProcessors()    { processors                               }
    op Core[]            getAllCores()         { processors.map[allCores].flatten.toEList }
    
    // AssuranceLevel
    op DesignAssuranceLevelType getAssuranceLevel() {
        if (!properties.filter[it instanceof DesignAssuranceLevelProperty].isNullOrEmpty) 
            (properties.filter[it instanceof DesignAssuranceLevelProperty].head as DesignAssuranceLevelProperty).value
        else 
            DesignAssuranceLevelType.NONE
    }
    
    op void setAssuranceLevel(DesignAssuranceLevelType newValue) {
        if (!properties.filter[it instanceof DesignAssuranceLevelProperty].isNullOrEmpty)
            (properties.filter[it instanceof DesignAssuranceLevelProperty].head as DesignAssuranceLevelProperty).value = newValue
        else
            properties.add(ModelFactory.eINSTANCE.createDesignAssuranceLevelProperty => [value = newValue])
    }
    
    //  PowerSupply
    op String getPowerSupply() {
        if (!properties.filter[it instanceof PowerSupplyProperty].isNullOrEmpty) 
            (properties.filter[it instanceof PowerSupplyProperty].head as PowerSupplyProperty).value
        else 
            null
    }
    
    op void setPowerSupply(String newValue) {
        if (!properties.filter[it instanceof PowerSupplyProperty].isNullOrEmpty) 
            (properties.filter[it instanceof PowerSupplyProperty].head as PowerSupplyProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createPowerSupplyProperty => [value = newValue])
    }
    
    //  BoardType
    op String getBoardType() {
        if (!properties.filter[it instanceof BoardTypeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof BoardTypeProperty].head as BoardTypeProperty).value
        else 
            null
    }
    
    op void setBoardType(String newValue) {
        if (!properties.filter[it instanceof BoardTypeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof BoardTypeProperty].head as BoardTypeProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createBoardTypeProperty => [value = newValue])
    }
    
    // RAM Capacity
    op int getRamCapacity() {
        if (!properties.filter[it instanceof RAMCapacityProperty].isNullOrEmpty) 
            (properties.filter[it instanceof RAMCapacityProperty].head as RAMCapacityProperty).value
        else 
            0
    }
    
    op void setRamCapacity(int newValue) {
        if (!properties.filter[it instanceof RAMCapacityProperty].isNullOrEmpty) 
            (properties.filter[it instanceof RAMCapacityProperty].head as RAMCapacityProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createRAMCapacityProperty => [value = newValue])
    }
    
    // ROM Capacity
    op int getRomCapacity() {
        if (!properties.filter[it instanceof ROMCapacityProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ROMCapacityProperty].head as ROMCapacityProperty).value
        else 
            0
    }
    
    op void setRomCapacity(int newValue) {
        if (!properties.filter[it instanceof ROMCapacityProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ROMCapacityProperty].head as ROMCapacityProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createROMCapacityProperty => [value = newValue])
    }
}

class Processor extends HardwareElement {
    derived String fullName get { board.fullName + "." + name }

    container Board board opposite processors
    contains Core[1..*] cores opposite processor

    op Core[] getAllCores() { cores }
    
    //  ProcessorType
    op String getProcessorType() {
        if (!properties.filter[it instanceof ProcessorTypeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ProcessorTypeProperty].head as ProcessorTypeProperty).value
        else 
            null
    }
    
    op void setProcessorType(String newValue) {
        if (!properties.filter[it instanceof ProcessorTypeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ProcessorTypeProperty].head as ProcessorTypeProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createProcessorTypeProperty => [value = newValue])
    }
}

class Core extends HardwareElement {
    derived String fullName get { processor.fullName + "." + name }
    container Processor processor opposite cores
    
    // CoreCapacity
    op int getCoreCapacity() {
        if (!properties.filter[it instanceof CoreCapacityProperty].isNullOrEmpty) 
            (properties.filter[it instanceof CoreCapacityProperty].head as CoreCapacityProperty).value
        else 
            0
    }
    
    op void setCoreCapacity(int newValue) {
        if (!properties.filter[it instanceof CoreCapacityProperty].isNullOrEmpty) 
            (properties.filter[it instanceof CoreCapacityProperty].head as CoreCapacityProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createCoreCapacityProperty => [value = newValue])
    }
    
    //  CoreArchitecture
    op String getCoreArchitecture() {
        if (!properties.filter[it instanceof CoreArchitectureProperty].isNullOrEmpty) 
            (properties.filter[it instanceof CoreArchitectureProperty].head as CoreArchitectureProperty).value
        else 
            null
    }
    
    op void setCoreArchitecture(String newValue) {
        if (!properties.filter[it instanceof CoreArchitectureProperty].isNullOrEmpty) 
            (properties.filter[it instanceof CoreArchitectureProperty].head as CoreArchitectureProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createCoreArchitectureProperty => [value = newValue])
    }
}

class ApplicationAlternative {
    String name
    contains Application[0..*] applications
}

class SoftwareElement {
    String name = ""
    contains Property[0..*]       properties

	op String toString() { getName }
	
	op CustomProperty[] getCustomPropertiesWithName(String name) {
        properties.filter[it instanceof CustomProperty && (it as CustomProperty).name == name].map[it as CustomProperty].toEList
    }
    
    op CustomProperty[] getCustomPropertiesWithNameAndValue(String name, String value) {
        getCustomPropertiesWithName(name).filter[(it as CustomStringProperty).value == value].toEList
    }
    
    op String getCustomStringProperty(String name) {
        if (!getCustomPropertiesWithName(name).filter[it instanceof CustomStringProperty].isNullOrEmpty)
            (getCustomPropertiesWithName(name).filter[it instanceof CustomStringProperty].head as CustomStringProperty).value
        else 
            null
    }
    
    op int getCustomIntProperty(String name) {
        if (!getCustomPropertiesWithName(name).filter[it instanceof CustomIntProperty].isNullOrEmpty)
            (getCustomPropertiesWithName(name).filter[it instanceof CustomIntProperty].head as CustomIntProperty).value
        else 
            -1
    }
}

class Application extends SoftwareElement {
    contains Task[1..*] tasks opposite application
    refers HardwareElement[0..*] restrictMappingToHardwareElements
    derived String fullName get { getName }
    
    //  DevelopedBy
    op String getDevelopedBy() {
        if (!properties.filter[it instanceof DevelopedByProperty].isNullOrEmpty) 
            (properties.filter[it instanceof DevelopedByProperty].head as DevelopedByProperty).value
        else 
            null
    }
    
    op void setDevelopedBy(String newValue) {
        if (!properties.filter[it instanceof DevelopedByProperty].isNullOrEmpty) 
            (properties.filter[it instanceof DevelopedByProperty].head as DevelopedByProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createDevelopedByProperty => [value = newValue])
    }
    
    // CriticalityLevel
    op DesignAssuranceLevelType getCriticalityLevel() {
        if (!properties.filter[it instanceof CriticalityLevelProperty].isNullOrEmpty) 
            (properties.filter[it instanceof CriticalityLevelProperty].head as CriticalityLevelProperty).value
        else 
            DesignAssuranceLevelType.NONE
    }
    
    op void setCriticalityLevel(DesignAssuranceLevelType newValue) {
        if (!properties.filter[it instanceof CriticalityLevelProperty].isNullOrEmpty)
            (properties.filter[it instanceof CriticalityLevelProperty].head as CriticalityLevelProperty).value = newValue
        else
            properties.add(ModelFactory.eINSTANCE.createCriticalityLevelProperty => [value = newValue])
    }
}

class Task extends SoftwareElement {    
    container Application application opposite tasks
    contains FeatureRequirement[0..*]        featureRequirements
    refers HardwareElement[0..*]             restrictMappingToHardwareElements
    
    derived String fullName get { application.getName + "." + getName }
    
    // CoreUtilization
    op int getCoreUtilization() {
        if (!properties.filter[it instanceof CoreUtilizationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof CoreUtilizationProperty].head as CoreUtilizationProperty).value
        else 
            0
    }
    
    op void setCoreUtilization(int newValue) {
        if (!properties.filter[it instanceof CoreUtilizationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof CoreUtilizationProperty].head as CoreUtilizationProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createCoreUtilizationProperty => [value = newValue])
    }
    
    // RamUtilization
    op int getRamUtilization() {
        if (!properties.filter[it instanceof RAMUtilizationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof RAMUtilizationProperty].head as RAMUtilizationProperty).value
        else 
            0
    }
    
    op void setRamUtilization(int newValue) {
        if (!properties.filter[it instanceof RAMUtilizationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof RAMUtilizationProperty].head as RAMUtilizationProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createRAMUtilizationProperty => [value = newValue])
    }
    
    // RomUtilization
    op int getRomUtilization() {
        if (!properties.filter[it instanceof ROMUtilizationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ROMUtilizationProperty].head as ROMUtilizationProperty).value
        else 
            0
    }
    
    op void setRomUtilization(int newValue) {
        if (!properties.filter[it instanceof ROMUtilizationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ROMUtilizationProperty].head as ROMUtilizationProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createROMUtilizationProperty => [value = newValue])
    }
    
    // Duration
    op int getDuration() {
        if (!properties.filter[it instanceof DurationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof DurationProperty].head as DurationProperty).value
        else 
            -1
    }
    
    op void setDuration(int newValue) {
        if (!properties.filter[it instanceof DurationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof DurationProperty].head as DurationProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createDurationProperty => [value = newValue])
    }
    
    // Period
    op int getPeriod() {
        if (!properties.filter[it instanceof PeriodProperty].isNullOrEmpty) 
            (properties.filter[it instanceof PeriodProperty].head as PeriodProperty).value
        else 
            -1
    }
    
    op void setPeriod(int newValue) {
        if (!properties.filter[it instanceof PeriodProperty].isNullOrEmpty) 
            (properties.filter[it instanceof PeriodProperty].head as PeriodProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createPeriodProperty => [value = newValue])
    }
    
    // EarlyTolerance
    op int getEarlyTolerance() {
        if (!properties.filter[it instanceof EarlyToleranceProperty].isNullOrEmpty) 
            (properties.filter[it instanceof EarlyToleranceProperty].head as EarlyToleranceProperty).value
        else 
            -1
    }
    
    op void setEarlyTolerance(int newValue) {
        if (!properties.filter[it instanceof EarlyToleranceProperty].isNullOrEmpty) 
            (properties.filter[it instanceof EarlyToleranceProperty].head as EarlyToleranceProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createEarlyToleranceProperty => [value = newValue])
    }
    
    // LateTolerance
    op int getLateTolerance() {
        if (!properties.filter[it instanceof LateToleranceProperty].isNullOrEmpty) 
            (properties.filter[it instanceof LateToleranceProperty].head as LateToleranceProperty).value
        else 
            -1
    }
    
    op void setLateTolerance(int newValue) {
        if (!properties.filter[it instanceof LateToleranceProperty].isNullOrEmpty) 
            (properties.filter[it instanceof LateToleranceProperty].head as LateToleranceProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createLateToleranceProperty => [value = newValue])
    }
    
    // MaxStartTime
    op int getMaxStartTime() {
        if (!properties.filter[it instanceof MaxStartTimeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MaxStartTimeProperty].head as MaxStartTimeProperty).value
        else 
            -1
    }
    
    op void setMaxStartTime(int newValue) {
        if (!properties.filter[it instanceof MaxStartTimeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MaxStartTimeProperty].head as MaxStartTimeProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createMaxStartTimeProperty => [value = newValue])
    }
    
    // MaxEndTime
    op int getMaxEndTime() {
        if (!properties.filter[it instanceof MaxEndTimeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MaxEndTimeProperty].head as MaxEndTimeProperty).value
        else 
            -1
    }
    
    op void setMaxEndTime(int newValue) {
        if (!properties.filter[it instanceof MaxEndTimeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MaxEndTimeProperty].head as MaxEndTimeProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createMaxEndTimeProperty => [value = newValue])
    }
    
    // AddInitTime
    op int getAddInitTime() {
        if (!properties.filter[it instanceof AddInitTimeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof AddInitTimeProperty].head as AddInitTimeProperty).value
        else 
            -1
    }
    
    op void setAddInitTime(int newValue) {
        if (!properties.filter[it instanceof AddInitTimeProperty].isNullOrEmpty) 
            (properties.filter[it instanceof AddInitTimeProperty].head as AddInitTimeProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createAddInitTimeProperty => [value = newValue])
    }
    // Slices
    op int getSlices() {
        if (!properties.filter[it instanceof SlicesProperty].isNullOrEmpty) 
            (properties.filter[it instanceof SlicesProperty].head as SlicesProperty).value
        else 
            -1
    }
    
    op void setSlices(int newValue) {
        if (!properties.filter[it instanceof SlicesProperty].isNullOrEmpty) 
            (properties.filter[it instanceof SlicesProperty].head as SlicesProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createSlicesProperty => [value = newValue])
    }
    // MinSliceDuration
    op int getMinSliceDuration() {
        if (!properties.filter[it instanceof MinSliceDurationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MinSliceDurationProperty].head as MinSliceDurationProperty).value
        else 
            -1
    }
    
    op void setMinSliceDuration(int newValue) {
        if (!properties.filter[it instanceof MinSliceDurationProperty].isNullOrEmpty) 
            (properties.filter[it instanceof MinSliceDurationProperty].head as MinSliceDurationProperty).value = newValue
        else 
            properties.add(ModelFactory.eINSTANCE.createMinSliceDurationProperty => [value = newValue])
    }
    
    // Periodicity 
    op PeriodicityType getPeriodicity() {
        if (!properties.filter[it instanceof PeriodicityProperty].isNullOrEmpty) 
            (properties.filter[it instanceof PeriodicityProperty].head as PeriodicityProperty).value
        else 
            PeriodicityType.STRICT
    }
    
    op void setPeriodicity(PeriodicityType newValue) {
        if (!properties.filter[it instanceof PeriodicityProperty].isNullOrEmpty)
            (properties.filter[it instanceof PeriodicityProperty].head as PeriodicityProperty).value = newValue
        else
            properties.add(ModelFactory.eINSTANCE.createPeriodicityProperty => [value = newValue])
    }
    
    // Color
    op Color getColor() {
        if (!properties.filter[it instanceof ColorProperty].isNullOrEmpty) 
            (properties.filter[it instanceof ColorProperty].head as ColorProperty).value
        else 
            Color.NONE
    }
    
    op void setColor(Color newValue) {
        if (!properties.filter[it instanceof ColorProperty].isNullOrEmpty)
            (properties.filter[it instanceof ColorProperty].head as ColorProperty).value = newValue
        else
            properties.add(ModelFactory.eINSTANCE.createColorProperty => [value = newValue])
    }
    
    //  AssignedCore
    op Core getAssignedCore() {
        if (!properties.filter[it instanceof AssignedCoreProperty].isNullOrEmpty) 
            (properties.filter[it instanceof AssignedCoreProperty].head as AssignedCoreProperty).value
        else 
            null
    }
    
    op void setAssignedCore(Core newValue) {
        if (!properties.filter[it instanceof AssignedCoreProperty].isNullOrEmpty)
            (properties.filter[it instanceof AssignedCoreProperty].head as AssignedCoreProperty).value = newValue
        else
            properties.add(ModelFactory.eINSTANCE.createAssignedCoreProperty => [value = newValue])
    }
}

class FeatureRequirement {
    String                          name            = ""
    HardwareArchitectureLevelType   hardwareLevel
    int                             units           = "-1"
    boolean                         shared          = "false"
    derived boolean isExclusive get { !isShared }
}

/* *********************************************** */
/*   MAPPING: RESTRICTIONS                         */
/* *********************************************** */
type ListOfTaskLists wraps EList<EList<Task>>

class MappingRelation{
    refers SoftwareElement[0..*] softwareElements
    HardwareArchitectureLevelType hardwareLevel
    
    derived ListOfTaskLists allTasks get {
    	val List<EList<Task>> list = newArrayList
    	for (se : softwareElements) {
    		if (se instanceof Application)
    			list.add(se.tasks)
    		if (se instanceof Task)
    			list.add(#[se].toEList)
    	}
    	return list.toEList
    }
    
    derived String softwareElementNames get {
    	softwareElements.join(', ')
    }
}

class DislocalityRelation   extends MappingRelation {}

class ColocalityRelation    extends MappingRelation {}

class DissimilarityRelation extends MappingRelation {
    contains DissimilarityClause[1] dissimilarityClause
}

class DissimilarityClause {}

// OR
class DissimilarityDisjunction extends DissimilarityClause {
    contains DissimilarityClause[2..*] dissimilarityClauses
}
// AND
class DissimilarityConjunction extends DissimilarityClause  {
    contains DissimilarityClause[2..*] dissimilarityClauses
}

// Basic Case
class DissimilarityEntry extends DissimilarityClause {
    DissimilarityAttributes dissimilarityAttribute
    derived HardwareArchitectureLevelType hardwareLevel get {
        switch (dissimilarityAttribute) {
            case COMPARTMENT_MANUFACTURER:  { return HardwareArchitectureLevelType.COMPARTMENT  }    
            case COMPARTMENT_POWERSUPPLY:   { return HardwareArchitectureLevelType.COMPARTMENT  }
            case BOX_MANUFACTURER:          { return HardwareArchitectureLevelType.BOX          }
            case BOARD_MANUFACTURER:        { return HardwareArchitectureLevelType.BOARD        }
            case BOARD_BOARDTYPE:           { return HardwareArchitectureLevelType.BOARD        }        
            case BOARD_POWERSUPPLY:         { return HardwareArchitectureLevelType.BOARD        }
            case BOARD_ASSURANCELEVEL:      { return HardwareArchitectureLevelType.BOARD        }
            case PROCESSOR_MANUFACTURER:    { return HardwareArchitectureLevelType.PROCESSOR    }
            case PROCESSOR_PROCESSORTYPE:   { return HardwareArchitectureLevelType.PROCESSOR    }
            case CORE_ARCHITECTURE:         { return HardwareArchitectureLevelType.CORE         }
        }
    }
}

enum DissimilarityAttributes {
    COMPARTMENT_MANUFACTURER    as "Compartment.Manufacturer"
    COMPARTMENT_POWERSUPPLY     as "Compartment.PowerSupply"
    BOX_MANUFACTURER            as "Box.Manufacturer"
    BOARD_MANUFACTURER          as "Board.Manufacturer"
    BOARD_BOARDTYPE             as "Board.Type"
    BOARD_POWERSUPPLY           as "Board.PowerSupply"
    BOARD_ASSURANCELEVEL        as "Board.DesignAssuranceLevel"
    PROCESSOR_MANUFACTURER      as "Processor.Manufacturer"
    PROCESSOR_PROCESSORTYPE     as "Processor.Type"
    CORE_ARCHITECTURE           as "Core.Architecture"
}

/* ********************************************** */
/* SCHEDULING: Restrictions                       */
/* ********************************************** */
class SchedulingRestriction {}

// Basic kinds of relations
class SimpleRelation extends SchedulingRestriction {
    refers Task[2..*] tasks
}

class ComplexRelation extends SchedulingRestriction {
    refers Task[1..*] tasks
    refers Task       otherTask
    int               delay    
}

// Concrete relations:
// Task1, Task2, ... start at the same time;
class RestrictionStartAtTheSameTime  extends SimpleRelation {}

// Task1, Task2, ... finish at the same time;
class RestrictionFinishAtTheSameTime extends SimpleRelation {}

// Task2 starts after Task1 has finished (with delay of min X);
// Task3, Task4, ...  start after Task1 has finished (with delay of min X);
class RestrictionStartAfterOtherFinished extends ComplexRelation {}

// Task2 starts after Task1 has started (with delay of min X);
// Task3, Task4, ...  start after Task1 has started (with delay of min X);
class RestrictionStartAfterOtherStarted extends ComplexRelation {}

// Task1, Task2, ... require disjoint execution;
class RestrictionDisjointExecution extends SimpleRelation {}


/* ********************************************** */
/* GENERAL ENUMS                                  */
/* ********************************************** */
    
enum HardwareArchitectureLevelType {
    CORE         as "Core"             = 0
    PROCESSOR    as "Processor"        = 1
    BOARD        as "Board"            = 2
    BOX          as "Box"              = 3
    COMPARTMENT  as "Compartment"      = 4
}

enum DesignAssuranceLevelType {
    NONE         as "None"             = 0
    QS           as "QS"               = 1
    D            as "D"                = 2
    C            as "C"                = 3
    B            as "B"                = 4
    A            as "A"                = 5
}

enum PeriodicityType {
    STRICT       as "strict"           = 0
    FLEXIBLE     as "flexible"         = 1
}

enum Color {
    NONE         as "none"             = -1
    BLACK        as "black"            = 0
    BLUE         as "blue"             = 1
    CYAN         as "cyan"             = 2
    GRAY         as "gray"             = 3
    GREEN        as "green"            = 4
    MAGENTA      as "magenta"          = 5
    RED          as "red"              = 6
    WHITE        as "white"            = 7
    YELLOW       as "yellow"           = 8 
    DARK_BLUE    as "darkblue"         = 9
    DARK_CYAN    as "darkcyan"         = 10
    DARK_GRAY    as "darkgray"         = 11
    DARK_GREEN   as "darkgreen"        = 12
    DARK_MAGENTA as "darkmagenta"      = 13
    DARK_RED     as "darkred"          = 14
    DARK_YELLOW  as "darkyellow"       = 15
}

/* ************************************** */
/* DESIGN SPACE EXPLORATION               */
/* ************************************** */
class RestrictionAlternative{
    String name
    contains DislocalityRelation[0..*]      dislocalityRelations
    contains ColocalityRelation[0..*]       colocalityRelations
    contains DissimilarityRelation[0..*]    dissimilarityRelations
}

class ExplorationCandidate {
    String name
    refers BoardAlternative[0..*]           boardAlternatives
    refers ApplicationAlternative[0..*]     applicationAlternatives
    refers RestrictionAlternative[0..*]     restrictionAlternatives
}

class ExplorationResult {
    refers ExplorationCandidate candidate
    refers AssistModel model
    refers MappingResult mappingResult
    boolean feasible
    Double absoluteScore
    Double scaledScore
}

abstract class AbstractDSEMetric {
    String  name
    boolean builtIn
    boolean higherScoreIsBetter
    
    op double computeAbsoluteScore(ExplorationResult result)
}

/* **************************************
 * RESULTS - MAPPING
 * ************************************** */
type Task2CoreMapType wraps HashMap<Task, Core>
type StringList wraps List<String>

interface Comparable wraps Comparable<MappingResult>{}

// Hack to get a Map in Xcore
// https://stackoverflow.com/questions/41387196/how-to-define-a-map-in-xcore
class MetricScorePair wraps java.util.Map$Entry {
    refers AbstractMappingMetric key
    Double value
}

class MappingResult extends Comparable {
    String                             name
    int                                index
    Task2CoreMapType                   task2CoreMap
    refers   AssistModel               model    
    contains MetricScorePair[]         metricAbsoluteScoresMap 
    contains MetricScorePair[]         metricScaledScoresMap
    boolean                            partialSolution = "false"
    
    op boolean isUsed(Core core) {
    	return !getMappedTasksForCore(core).isNullOrEmpty
    }
    
    op boolean isUsed(Processor processor) {
    	return !processor.cores.filter[isUsed(it)].isNullOrEmpty
    }
    
    op boolean isUsed(Board board) {
    	return !board.processors.filter[isUsed(it)].isNullOrEmpty
    }
    
    op boolean isUsed(Box box) {
    	return !box.boards.filter[isUsed(it)].isNullOrEmpty
    }
    
    op boolean isUsed(Compartment compartment) {
    	return !compartment.boxes.filter[isUsed(it)].isNullOrEmpty
    }
    
    derived double absoluteTotalScore get {
        if (metricAbsoluteScoresMap.keySet.empty)     0.0
        else metricAbsoluteScoresMap.values.reduce[p1, p2|p1+p2]
    }

    derived double scaledTotalScore get {
        if (metricScaledScoresMap.keySet.empty)        0.0
        else metricScaledScoresMap.values.reduce[p1, p2|p1+p2]
    }

    op Task[] getMappedTasksForCore(Core core) {
        getTask2CoreMap.keySet.filter[getTask2CoreMap.get(it) == core].toEList
    }
    
    op int getAbsoluteCoreUtilization(Core core) {
        val taskList = getMappedTasksForCore(core)
        if (!taskList.isNullOrEmpty) taskList.map[it.coreUtilization].reduce[p1, p2|p1 + p2]
        else     0
    }
    
    op double getRelativeCoreUtilization(Core core) {
        if (core.coreCapacity > 0) new Double(getAbsoluteCoreUtilization(core)) / new Double(core.coreCapacity)
        else     -1.0
    }
    
    /* Return the hardware element of the level level that the task task is being mapped to */
    op HardwareElement getHardwareElementForTask(Task task, int level) {
        if (level == 0)         getTask2CoreMap.get(task)
        else if (level == 1)    getTask2CoreMap.get(task).processor 
        else if (level == 2)    getTask2CoreMap.get(task).processor.board
        else if (level == 3)    getTask2CoreMap.get(task).processor.board.box
        else if (level == 4)    getTask2CoreMap.get(task).processor.board.box.compartment
        else                     null
    }

    /* This creates the list of mapping elements; each elements contains all hardware / software elements */
    op SingleMappingElement[] getMappingElements() {
        getTask2CoreMap.entrySet.map[ 

            /* Retrieve the entries from the map */
            val application = key.eContainer as Application
            val task        = key
            val core        = value
            val processor     = value.eContainer as Processor
            val board        = value.eContainer.eContainer as Board
            val box            = value.eContainer.eContainer.eContainer as Box
            val compartment = value.eContainer.eContainer.eContainer.eContainer as Compartment
            
            /* Create the SingleMappingElement based on that data */
            ModelFactory.eINSTANCE.createSingleMappingElement => [
                it.application     = application
                it.task            = task 
                it.core            = core
                it.processor       = processor
                it.board           = board
                it.box             = box
                it.compartment     = compartment    
            ]
            
        ].toEList
    }
    
    op int compareTo(MappingResult o) {
        Double.compare(o.scaledTotalScore, scaledTotalScore)
    }
    
    op String toString() {
        val sb = new StringBuilder
        sb.append("Result        : " + getName + " (" + getIndex + ")\n")
        sb.append("Absolute Score: " + absoluteTotalScore + "\n")
        sb.append("Relative Score: " + scaledTotalScore + "\n")
        for (task : getModel.allTasks) {
            sb.append(task.fullName + "\t->\t" + getTask2CoreMap.get(task).fullName + '\n')
        }
        sb.toString
    }
}

class SingleMappingElement {
    refers    Application        application
    refers    Task               task
    refers    Core               core
    refers    Processor          processor
    refers    Board              board
    refers    Box                box
    refers    Compartment        compartment
}

abstract class AbstractMappingMetric {
    String  name
    boolean builtIn
    boolean higherScoreIsBetter
    int     weight
    
    op double computeAbsoluteScore(MappingResult result)
}

/* ************************************** 
 * RESULTS - SCHEDULING
 * ************************************* */
type Task2ExecutionInstancesMapType wraps HashMap<Task, List<TaskExecutionInstance>> 

class SchedulingResult {
    String                             name                      = ""
    int                                hyperPeriodLength         = "-1"
    refers AssistModel                 model
    Task2ExecutionInstancesMapType     schedule
}

class TaskExecutionInstance {
    int begin = "-1"
    int end   = "-1"
    op String toString()            { "[" + begin + ", " + end + "]" }
}