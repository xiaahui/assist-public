@GenModel(
	modelPluginID="ch.hilbri.assist.model", 
	editDirectory="/ch.hilbri.assist.model.edit/src",
	editPluginID="ch.hilbri.assist.model.edit", 
	editorDirectory="/ch.hilbri.assist.model.editor/src",
	editorPluginID="ch.hilbri.assist.model.editor", 
	generateModelWizard="false", 
	generateExampleClass="false")

package ch.hilbri.assist.model

import java.util.HashMap
import java.util.List

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

class AssistModel {
	String			systemName			= ""
	int 				minHypPeriodLength 	= "-1"
	int				taskSwitchDelay 		= "0"
	
	contains 		Compartment[1..*] 				compartments
	contains 		Application[1..*] 				applications
	contains 		DislocalityRelation[0..*] 		dislocalityRelations
	contains 		ColocalityRelation[0..*] 		colocalityRelations
	contains 		DissimilarityRelation[0..*] 	dissimilarityRelations

	op Compartment[] 	getAllCompartments() 	{ compartments										}
	op Box[] 			getAllBoxes() 			{ compartments.map[allBoxes].flatten.toEList			}
	op Board[] 			getAllBoards() 			{ compartments.map[allBoards].flatten.toEList			}
	op Processor[] 		getAllProcessors() 		{ compartments.map[allProcessors].flatten.toEList		}
	op Core[] 			getAllCores() 			{ compartments.map[allCores].flatten.toEList			}
	op Task[]			getAllTasks() 			{ applications.map[tasks].flatten.toEList				}
	
	op HardwareElement[] getAllHardwareElements(int level) {
		if (level == 0)			allCores.map[it as HardwareElement]
		else if (level == 1)		allProcessors.map[it as HardwareElement]
		else if (level == 2)		allBoards.map[it as HardwareElement]
		else if (level == 3)		allBoxes.map[it as HardwareElement]
		else if (level == 4)		allCompartments.map[it as HardwareElement] 
		else 					null
	}
}

class HardwareElement {
	String name				 	= ""
	String manufacturer  		= ""
	contains MetricParameter[0..*] metricParameters
}

class Compartment extends HardwareElement {
	String powerSupply			= ""
	derived String fullName get { name }
	contains Box[1..*] boxes opposite compartment
	op Box[] 			getAllBoxes() 		{ boxes	}
	op Board[] 			getAllBoards() 		{ boxes.map[allBoards].flatten.toEList 		}
	op Processor[] 		getAllProcessors() 	{ boxes.map[allProcessors].flatten.toEList 	}
	op Core[] 			getAllCores() 		{ boxes.map[allCores].flatten.toEList		}
}


class Box extends HardwareElement {
	container Compartment compartment opposite boxes
	contains Board[0..*] boards opposite box
	derived String fullName get { compartment.fullName + "." + name }
	op Board[] 			getAllBoards() 		{ boards }
	op Processor[] 		getAllProcessors() 	{ boards.map[allProcessors].flatten.toEList 	}
	op Core[] 			getAllCores() 		{ boards.map[allCores].flatten.toEList		}
}

class Board extends HardwareElement {
	String 							boardType		= ""
	String 							powerSupply		= ""
	DesignAssuranceLevelType 		assuranceLevel 	= "None"
	int 							ramCapacity 	= "0"
	int 							romCapacity 	= "0"
	container 	Box 				box 			opposite boards
	contains 	Processor[1..*] 	processors 		opposite board
	contains 	IOAdapter[0..*] 	ioAdapters
	derived String fullName get { box.fullName + "." + name }
	op String			toString() 			{ name }
	op Processor[] 		getAllProcessors() 	{ processors }
	op Core[] 			getAllCores() 		{ processors.map[allCores].flatten.toEList }
}

class Processor extends HardwareElement {
	String processorType = ""
	derived String fullName get { board.fullName + "." + name }
	container Board board opposite processors
	contains Core[1..*] cores opposite processor
	op Core[] getAllCores() { cores }
}

class Core extends HardwareElement {
	String architecture = ""
	int capacity 		= "0"
	derived String fullName get { processor.fullName + "." + name }
	container Processor processor opposite cores
}

class IOAdapter {
	String name 				= ""
	int totalCount 				= "0"
	IOAdapterType adapterType 	= "None"
}

class Application {
	String 						name 				= ""
	String 						developedBy			= ""
	DesignAssuranceLevelType 	criticalityLevel	= "None"
	contains Task[1..*] 		tasks	opposite application
	contains MetricParameter[0..*] 	metricParameters
	refers HardwareElement[0..*] restrictMappingToHardwareElements
	op String 			toString() { name }
	derived String 		fullName get { name }
}

class Task {	
	String name 												= ""
	int coreUtilization 										= "0"
	int ramUtilization 											= "0"
	int romUtilization											= "0"
	int duration 												= "-1"
	int period													= "-1"
	int earlyTolerance											= "-1"
	int lateTolerance											= "-1"
	int maxStartTime											= "-1"
	int maxEndTime												= "-1"
	int addInitTime												= "-1"
	int slices													= "-1"
	int minSliceDuration										= "-1"
	PeriodicityType periodicity									= "strict"
	Color color													= "none"
	container Application application opposite tasks
	contains IOAdapterRequirement[0..*] ioAdapterRequirements
	contains MetricParameter[0..*] metricParameters
	derived String fullName get { application.name + "." + name }
	refers HardwareElement[0..*] restrictMappingToHardwareElements
	refers Core[0..1] 	assignedCore
	op String 			toString() { name }
}

enum Color {
	NONE			as "none"			= -1
	BLACK			as "black"			= 0
	BLUE			as "blue" 			= 1
	CYAN			as "cyan"			= 2
	GRAY			as "gray"			= 3
	GREEN			as "green"			= 4
	MAGENTA			as "magenta"		= 5
	RED				as "red"			= 6
	WHITE			as "white"			= 7
	YELLOW			as "yellow"			= 8 
	DARK_BLUE		as "darkblue"		= 9
	DARK_CYAN		as "darkcyan"		= 10
	DARK_GRAY		as "darkgray"		= 11
	DARK_GREEN		as "darkgreen"		= 12
	DARK_MAGENTA	as "darkmagenta"	= 13
	DARK_RED		as "darkred"		= 14
	DARK_YELLOW		as "darkyellow"		= 15
}

/* *********************************************** */
/*   REQUIREMENTS / RELATIONS                      */
/* *********************************************** */
class IOAdapterRequirement {
	IOAdapterType 				adapterType				= "None"
	int 							requiredAdapterCount 	= "0"
	boolean 						isSharedAllowed 			= "false"
	boolean 						isExclusiveOnly 			= "false"
}

class DislocalityRelation{
	refers Application[1..*] applications
	HardwareArchitectureLevelType hardwareLevel
}

class ColocalityRelation {
	refers Application[0..*] applications
	HardwareArchitectureLevelType hardwareLevel
}

class DissimilarityRelation {
	refers Application[0..*] applications
	contains DissimilarityClause[1] dissimilarityClause
}

class DissimilarityClause {}

// OR
class DissimilarityDisjunction extends DissimilarityClause {
	contains DissimilarityClause[2..*] dissimilarityClauses
}
// AND
class DissimilarityConjunction extends DissimilarityClause  {
	contains DissimilarityClause[2..*] dissimilarityClauses
}

// Basic Case
class DissimilarityEntry extends DissimilarityClause {
	DissimilarityAttributes dissimilarityAttribute
	derived HardwareArchitectureLevelType hardwareLevel get {
		switch (dissimilarityAttribute) {
			case COMPARTMENT_MANUFACTURER: 	{ return HardwareArchitectureLevelType.COMPARTMENT 	}	
			case COMPARTMENT_POWERSUPPLY: 	{ return HardwareArchitectureLevelType.COMPARTMENT	}
			case BOX_MANUFACTURER: 			{ return HardwareArchitectureLevelType.BOX			}
			case BOARD_MANUFACTURER: 		{ return HardwareArchitectureLevelType.BOARD		}
			case BOARD_BOARDTYPE: 			{ return HardwareArchitectureLevelType.BOARD		}		
			case BOARD_POWERSUPPLY: 		{ return HardwareArchitectureLevelType.BOARD		}
			case BOARD_ASSURANCELEVEL: 		{ return HardwareArchitectureLevelType.BOARD		}
			case PROCESSOR_MANUFACTURER: 	{ return HardwareArchitectureLevelType.PROCESSOR	}
			case PROCESSOR_PROCESSORTYPE: 	{ return HardwareArchitectureLevelType.PROCESSOR	}
			case CORE_ARCHITECTURE: 		{ return HardwareArchitectureLevelType.CORE			}
		}
	}
}

enum DissimilarityAttributes {
	COMPARTMENT_MANUFACTURER	as "Compartment.Manufacturer"
	COMPARTMENT_POWERSUPPLY		as "Compartment.PowerSupply"
	BOX_MANUFACTURER			as "Box.Manufacturer"
	BOARD_MANUFACTURER			as "Board.Manufacturer"
	BOARD_BOARDTYPE				as "Board.Type"
	BOARD_POWERSUPPLY			as "Board.PowerSupply"
	BOARD_ASSURANCELEVEL		as "Board.DesignAssuranceLevel"
	PROCESSOR_MANUFACTURER		as "Processor.Manufacturer"
	PROCESSOR_PROCESSORTYPE		as "Processor.Type"
	CORE_ARCHITECTURE			as "Core.Architecture"
}

class MetricParameter {
	String name = ""
	int value = "0"
}

enum HardwareArchitectureLevelType {
	CORE 		as "Core" 			= 0
	PROCESSOR 	as "Processor"		= 1
	BOARD		as "Board"			= 2
	BOX			as "Box"			= 3
	COMPARTMENT	as "Compartment"	= 4
}

enum DesignAssuranceLevelType {
	NONE 		as "None"			= 0
	QS 			as "QS"				= 1
	D 			as "D"				= 2
	C 			as "C"				= 3
	B 			as "B"				= 4
	A 			as "A"				= 5
}

enum IOAdapterType {
	NONE		as "None"
	CAN 		as "Can"
	ELB			as "Enhanced Local Bus"
	ETH			as "Ethernet"
	ANALOG 		as "Analog"
	DIGITAL		as "Digital"
	SERIAL		as "Serial"
}

enum PeriodicityType {
	STRICT 		as "strict" 		= 0
	FLEXIBLE		as "flexible"	= 1
}

/* *******************************************************
 * DESIGN SPACE EXPLORATION - A SPECIALIZED ASSIST MODEL 
 * ******************************************************* */
class AssistModelDSE extends AssistModel {
	contains ApplicationAlternatives[0..*] 	applicationAlternatives
	contains RestrictionAlternatives[0..*]	restrictionAlternatives
	contains ExplorationCandidate[0..*]		explorationCandidates
}

class BoxDSE extends Box {
	contains BoardAlternatives[0..*] boardAlternatives
}

class BoardAlternatives {  // XOR
	contains BoardAlternative[0..*] alternatives
}

class BoardAlternative {
	String name
	contains Board[0..*] boards 
}

class ApplicationAlternatives {  // XOR
	contains ApplicationAlternative[0..*] alternatives
}

class ApplicationAlternative {
	String name
	contains Application[0..*] applications
}

class RestrictionAlternatives {
	contains RestrictionAlternative[0..*] alternatives
}

class RestrictionAlternative{
	String name
	contains DislocalityRelation[0..*] dislocalityRelations
	contains ColocalityRelation[0..*] colocalityRelations
	// dissimilarityRelations
}

class ExplorationCandidate {
	String name
	refers BoardAlternative[0..*] 		boardAlternatives
	refers ApplicationAlternative[0..*] applicationAlternatives
	refers RestrictionAlternative[0..*] restrictionAlternatives
}

/* **************************************
 * RESULTS - MAPPING
 * ************************************** */
type Task2CoreMapType wraps HashMap<Task, Core>
type StringList wraps List<String>

interface Comparable wraps Comparable<MappingResult>{}

// Hack to get a Map in Xcore
// https://stackoverflow.com/questions/41387196/how-to-define-a-map-in-xcore
class MetricScorePair wraps java.util.Map$Entry {
    refers AbstractMetric key
    Double value
}

class MappingResult extends Comparable {
	String							name
	int								index
	refers AssistModel				model	
 	Task2CoreMapType				task2CoreMap
 	contains MetricScorePair[]		metricAbsoluteScoresMap 
 	contains MetricScorePair[]		metricScaledScoresMap
 	boolean 						partialSolution = "false"
	
	derived double absoluteTotalScore get {
		if (metricAbsoluteScoresMap.keySet.empty) 	0.0
		else metricAbsoluteScoresMap.values.reduce[p1, p2|p1+p2]
	}

	derived double scaledTotalScore get {
		if (metricScaledScoresMap.keySet.empty)		0.0
		else metricScaledScoresMap.values.reduce[p1, p2|p1+p2]
	}

	op Task[] getMappedTasksForCore(Core core) {
		getTask2CoreMap.keySet.filter[getTask2CoreMap.get(it) == core].toEList
	}
	
	op int getAbsoluteCoreUtilization(Core core) {
		val taskList = getMappedTasksForCore(core)
		if (!taskList.isNullOrEmpty) taskList.map[it.coreUtilization].reduce[p1, p2|p1 + p2]
		else 	0
	}
	
	op double getRelativeCoreUtilization(Core core) {
		if (core.capacity > 0) new Double(getAbsoluteCoreUtilization(core)) / new Double(core.capacity)
		else 	-1.0
	}
	
	/* Return the hardware element of the level level that the task task is being mapped to */
	op HardwareElement getHardwareElementForTask(Task task, int level) {
		if (level == 0) 		getTask2CoreMap.get(task)
		else if (level == 1)	getTask2CoreMap.get(task).processor 
		else if (level == 2)	getTask2CoreMap.get(task).processor.board
		else if (level == 3)	getTask2CoreMap.get(task).processor.board.box
		else if (level == 4)	getTask2CoreMap.get(task).processor.board.box.compartment
		else 					null
	}


	/* This creates the list of mapping elements; each elements contains all hardware / software elements */
	op SingleMappingElement[]			getMappingElements() {
		getTask2CoreMap.entrySet.map[ 

			/* Retrieve the entries from the map */
			val application 	= key.eContainer as Application
			val task			= key
			val core			= value
			val processor 	= value.eContainer as Processor
			val board		= value.eContainer.eContainer as Board
			val box			= value.eContainer.eContainer.eContainer as Box
			val compartment 	= value.eContainer.eContainer.eContainer.eContainer as Compartment
			
			/* Create the SingleMappingElement based on that data */
			ModelFactory.eINSTANCE.createSingleMappingElement => [
				it.application 	= application
				it.task 			= task 
				it.core 			= core
				it.processor		= processor
				it.board			= board
				it.box			= box
				it.compartment	= compartment	
			]
			
		].toEList
	}
	
	op int compareTo(MappingResult o) {
		Double.compare(o.scaledTotalScore, scaledTotalScore)
	}
	
	op String toString() {
		val sb = new StringBuilder
		sb.append("Result        : " + getName + " (" + getIndex + ")\n")
		sb.append("Absolute Score: " + absoluteTotalScore + "\n")
		sb.append("Relative Score: " + scaledTotalScore + "\n")
		for (task : getModel.allTasks) {
			sb.append(task.fullName + "\t->\t" + getTask2CoreMap.get(task).fullName + '\n')
		}
		sb.toString
	}
}

class SingleMappingElement {
	refers 	Application		application
	refers 	Task				task
	refers 	Core				core
	refers	Processor		processor
	refers	Board			board
	refers 	Box				box
	refers	Compartment		compartment
}

abstract class AbstractMetric {
	String name
	boolean builtIn
	boolean higherScoreIsBetter
	int		weight
	
	op double computeAbsoluteScore(MappingResult result)
}

/* ************************************** 
 * RESULTS - SCHEDULING
 * ************************************* */
type Task2ExecutionInstancesMapType wraps HashMap<Task, List<TaskExecutionInstance>> 

class AssistModelSchedulingResult {
	String name 				= ""
	int hyperPeriodLength 		= "-1"
	refers AssistModel 				model
	Task2ExecutionInstancesMapType 	schedule
}

class TaskExecutionInstance {
	int begin = "-1"
	int end   = "-1"
}