/**
 * generated by Xtext
 */
package ch.hilbri.assist.mappingdsl.ui.outline;

import ch.hilbri.assist.datamodel.model.Application;
import ch.hilbri.assist.datamodel.model.ApplicationGroup;
import ch.hilbri.assist.datamodel.model.AssistModel;
import ch.hilbri.assist.datamodel.model.CommunicationRelation;
import ch.hilbri.assist.datamodel.model.DislocalityRelation;
import ch.hilbri.assist.datamodel.model.DissimilarityRelation;
import ch.hilbri.assist.datamodel.model.HardwareElementContainer;
import ch.hilbri.assist.datamodel.model.Network;
import ch.hilbri.assist.datamodel.model.ProximityRelation;
import ch.hilbri.assist.mappingdsl.ui.outline.VirtualOutlineNode;
import java.net.URL;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.Path;
import org.eclipse.core.runtime.Platform;
import org.eclipse.emf.common.util.EList;
import org.eclipse.jface.resource.ImageDescriptor;
import org.eclipse.xtext.ui.editor.outline.IOutlineNode;
import org.eclipse.xtext.ui.editor.outline.impl.DefaultOutlineTreeProvider;
import org.osgi.framework.Bundle;

/**
 * Customization of the default outline structure.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#outline
 */
@SuppressWarnings("all")
public class MappingDSLOutlineTreeProvider extends DefaultOutlineTreeProvider {
  public void _createChildren(final IOutlineNode parentNode, final AssistModel model) {
    final Bundle bundle = Platform.getBundle("ch.hilbri.assist.mappingdsl.ui");
    Path _path = new Path("icons/outline_view_folder_16x16.png");
    URL _find = FileLocator.find(bundle, _path, null);
    final ImageDescriptor imgfolderDesc = ImageDescriptor.createFromURL(_find);
    Path _path_1 = new Path("icons/outline_view_subfolder_16x16.png");
    URL _find_1 = FileLocator.find(bundle, _path_1, null);
    final ImageDescriptor imgsubfolderDesc = ImageDescriptor.createFromURL(_find_1);
    final VirtualOutlineNode hardwareNode = new VirtualOutlineNode(parentNode, imgfolderDesc, "Hardware", false);
    EList<HardwareElementContainer> _hardwareContainer = model.getHardwareContainer();
    for (final HardwareElementContainer hw : _hardwareContainer) {
      this.createNode(hardwareNode, hw);
    }
    final VirtualOutlineNode applicationsNode = new VirtualOutlineNode(parentNode, imgfolderDesc, "Applications", false);
    EList<Application> _applications = model.getApplications();
    for (final Application sw : _applications) {
      this.createNode(applicationsNode, sw);
    }
    EList<ApplicationGroup> _applicationGroups = model.getApplicationGroups();
    boolean _isEmpty = _applicationGroups.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      final VirtualOutlineNode appGroupNode = new VirtualOutlineNode(parentNode, imgfolderDesc, "Application Groups", false);
      EList<ApplicationGroup> _applicationGroups_1 = model.getApplicationGroups();
      for (final ApplicationGroup group : _applicationGroups_1) {
        this.createNode(appGroupNode, group);
      }
    }
    boolean _or = false;
    EList<DislocalityRelation> _dislocalityRelations = model.getDislocalityRelations();
    boolean _isEmpty_1 = _dislocalityRelations.isEmpty();
    boolean _not_1 = (!_isEmpty_1);
    if (_not_1) {
      _or = true;
    } else {
      EList<DissimilarityRelation> _dissimilarityRelations = model.getDissimilarityRelations();
      boolean _isEmpty_2 = _dissimilarityRelations.isEmpty();
      boolean _not_2 = (!_isEmpty_2);
      _or = _not_2;
    }
    if (_or) {
      final VirtualOutlineNode safetyRelationNode = new VirtualOutlineNode(parentNode, imgfolderDesc, "Safety", false);
      EList<DislocalityRelation> _dislocalityRelations_1 = model.getDislocalityRelations();
      boolean _isEmpty_3 = _dislocalityRelations_1.isEmpty();
      boolean _not_3 = (!_isEmpty_3);
      if (_not_3) {
        final VirtualOutlineNode dislocalRelationNode = new VirtualOutlineNode(safetyRelationNode, imgsubfolderDesc, "Dislocality Constraints", false);
        EList<DislocalityRelation> _dislocalityRelations_2 = model.getDislocalityRelations();
        for (final DislocalityRelation r : _dislocalityRelations_2) {
          this.createNode(dislocalRelationNode, r);
        }
      }
      EList<DissimilarityRelation> _dissimilarityRelations_1 = model.getDissimilarityRelations();
      boolean _isEmpty_4 = _dissimilarityRelations_1.isEmpty();
      boolean _not_4 = (!_isEmpty_4);
      if (_not_4) {
        final VirtualOutlineNode dissimRelationNode = new VirtualOutlineNode(safetyRelationNode, imgsubfolderDesc, "Dissimilarity Constraints", false);
        EList<DissimilarityRelation> _dissimilarityRelations_2 = model.getDissimilarityRelations();
        for (final DissimilarityRelation r_1 : _dissimilarityRelations_2) {
          this.createNode(dissimRelationNode, r_1);
        }
      }
    }
    boolean _or_1 = false;
    EList<Network> _networks = model.getNetworks();
    boolean _isEmpty_5 = _networks.isEmpty();
    boolean _not_5 = (!_isEmpty_5);
    if (_not_5) {
      _or_1 = true;
    } else {
      EList<CommunicationRelation> _communicationRelations = model.getCommunicationRelations();
      boolean _isEmpty_6 = _communicationRelations.isEmpty();
      boolean _not_6 = (!_isEmpty_6);
      _or_1 = _not_6;
    }
    if (_or_1) {
      final VirtualOutlineNode networkNode = new VirtualOutlineNode(parentNode, imgfolderDesc, "Networks and Communication", false);
      EList<Network> _networks_1 = model.getNetworks();
      boolean _isEmpty_7 = _networks_1.isEmpty();
      boolean _not_7 = (!_isEmpty_7);
      if (_not_7) {
        final VirtualOutlineNode physNetworksNode = new VirtualOutlineNode(networkNode, imgsubfolderDesc, "Physical Networks", false);
        EList<Network> _networks_2 = model.getNetworks();
        for (final Network n : _networks_2) {
          this.createNode(physNetworksNode, n);
        }
      }
      EList<CommunicationRelation> _communicationRelations_1 = model.getCommunicationRelations();
      boolean _isEmpty_8 = _communicationRelations_1.isEmpty();
      boolean _not_8 = (!_isEmpty_8);
      if (_not_8) {
        final VirtualOutlineNode commRelationNode = new VirtualOutlineNode(networkNode, imgsubfolderDesc, "Logical Communication", false);
        EList<CommunicationRelation> _communicationRelations_2 = model.getCommunicationRelations();
        for (final CommunicationRelation r_2 : _communicationRelations_2) {
          this.createNode(commRelationNode, r_2);
        }
      }
    }
    EList<ProximityRelation> _proximityRelations = model.getProximityRelations();
    boolean _isEmpty_9 = _proximityRelations.isEmpty();
    boolean _not_9 = (!_isEmpty_9);
    if (_not_9) {
      final VirtualOutlineNode proximityRelationNode = new VirtualOutlineNode(parentNode, imgfolderDesc, "Proximity", false);
      EList<ProximityRelation> _proximityRelations_1 = model.getProximityRelations();
      for (final ProximityRelation r_3 : _proximityRelations_1) {
        this.createNode(proximityRelationNode, r_3);
      }
    }
  }
}
