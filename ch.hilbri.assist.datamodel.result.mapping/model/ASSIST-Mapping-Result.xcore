@GenModel(
	generateModelWizard="false", 
	generateExampleClass="false"
)

package ch.hilbri.assist.datamodel.result.mapping

import ch.hilbri.assist.datamodel.model.AssistModel
import ch.hilbri.assist.datamodel.model.EqInterface
import ch.hilbri.assist.datamodel.model.HardwareElement
import ch.hilbri.assist.datamodel.model.Pin
import java.util.HashMap
import org.eclipse.emf.common.util.EList

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

interface Comparable wraps Comparable<Result>{}

type EqInterfacePinMapType wraps HashMap<EqInterface, Pin>
type HardwareElementMappingsMapType wraps HashMap<HardwareElement, EList<EqInterface>>

class Result extends Comparable {
	String								name
	refers AssistModel					model
	EqInterfacePinMapType 				mapping
	HardwareElementMappingsMapType		mappingsForHardwareElements
	boolean 							partialSolution = "false"
	int									solutionFoundOrderId
	
	contains Evaluation[0..1] 			evaluation

	op EqInterface[] 	getAllUnmappedEqInterfaces() 	{ model.interfacesBlock.eqInterfaces.filter[!mapping.keySet.contains(it)].toEList }
	op double			getCompletenessAsPercentage()	{ 100 - allUnmappedEqInterfaces.length * 100 / model.interfacesBlock.eqInterfaces.length }
	
	op Pin				getPinForEqInterface(EqInterface iface) { if (mapping.keySet.contains(iface)) mapping.get(iface)
																  else null 												}

	op EqInterface[]	getAllMappedEqInterfaces(HardwareElement elem) 	{ mappingsForHardwareElements.get(elem) }
	op EqInterface		getEqInterfaceForPin(Pin p)						{ getAllMappedEqInterfaces(p).head 		}
	
	op int compareTo(Result o) {
		Double.compare(o.evaluation.totalScaledScore, evaluation.totalScaledScore)
	}
}

abstract class AbstractMetric  {
	String 								name
	int									weight
	boolean 							higherScoreIsBetter
	boolean 							builtIn = "false"
	op double 							computeAbsoluteScore(Result result)
}

type MetricScoreMap wraps HashMap<AbstractMetric, Double>

class Evaluation {

	MetricScoreMap						absoluteScores
	MetricScoreMap						scaledScores

	refers AbstractMetric[0..*] 		metricsUsed
	
	derived double						totalScaledScore get { 
		if (scaledScores == null || scaledScores.empty) 	0.0
		else 												scaledScores.values.reduce[i1, i2 | i1 + i2]
	}
}

