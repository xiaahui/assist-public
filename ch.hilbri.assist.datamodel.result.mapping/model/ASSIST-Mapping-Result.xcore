@GenModel(
	generateModelWizard="false", 
	generateExampleClass="false"
)

package ch.hilbri.assist.datamodel.result.mapping

import ch.hilbri.assist.datamodel.model.AssistModel
import ch.hilbri.assist.datamodel.model.Connector
import ch.hilbri.assist.datamodel.model.EqInterface

import java.util.HashMap
import org.eclipse.emf.common.util.BasicEList

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

interface Comparable wraps Comparable<Result>{}

type EqInterfaceConnectorMapType wraps HashMap<EqInterface, Connector>

class Result extends Comparable {
	String								name
	refers AssistModel					model
	EqInterfaceConnectorMapType 		mapping
	contains Evaluation[0..1] 			evaluation

	op int compareTo(Result o) {
		val double diff = this?.evaluation.totalScaledScore - o?.evaluation.totalScaledScore;
		if (diff < 0.0)	return 1;
		if (diff > 0.0)	return -1;
		return 0;
	}
	
	op EqInterface[] getAllMappedEqInterfacesForConnector(Connector connector) {
		val list = new BasicEList<EqInterface>
		for (iface : mapping.keySet)
			if (mapping.get(iface) == connector)
				list.add(iface)
		return list
	}

	boolean 			partialSolution 		= "false"
	
	op EqInterface[] 	getAllUnmappedEqInterfaces() 	{ return model.eqInterfaces.filter[!mapping.keySet.contains(it)].toEList 			}
	op double			getCompletenessAsPercentage()	{ return 100 - allUnmappedEqInterfaces.length * 100 / model.eqInterfaces.length 	}
}

abstract class AbstractMetric  {
	String 			name
	int				weight
	boolean 		higherScoreIsBetter
	boolean 		builtIn = "false"
	op double 		computeAbsoluteScore(Result result)
}

type MetricScoreMap wraps HashMap<AbstractMetric, Double>

class Evaluation {

	MetricScoreMap					absoluteScores
	MetricScoreMap					scaledScores
	
	derived double					totalScaledScore get { 
		if ((scaledScores == null) || (scaledScores.keySet.size == 0)) return 0.0
		else scaledScores.values.reduce[i1, i2 | i1 + i2]
	}

	refers AbstractMetric[0..*] 	metricsUsed
}

