@GenModel(
	modelPluginID="ch.hilbri.assist.datamodel.model",
	editDirectory="/ch.hilbri.assist.datamodel.model.edit/src", 
	editPluginID="ch.hilbri.assist.datamodel.model.edit",
	editorDirectory="/ch.hilbri.assist.datamodel.model.editor/src", 
	editorPluginID="ch.hilbri.assist.datamodel.model.editor",
	generateModelWizard="false", 
	generateExampleClass="false" 
 )

package ch.hilbri.assist.datamodel.model

import org.eclipse.emf.common.util.BasicEList


annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

class AssistModel {
	String 									name 				= ""

	contains Compartment[0..*]				compartments
	contains EqInterface[0..*]				eqInterfaces
	contains EqInterfaceGroup[0..*]			eqInterfaceGroups
	contains DislocalityRelation[0..*]		dislocalityRelations
	contains ColocalityRelation[0..*]		colocalityRelations
	contains ValidDeployment[0..*]			validDeployments
	contains InvalidDeployment[0..*]		invalidDeployments

	
	op Compartment[] getAllCompartments() {
		return compartments
	}
	
	op RDC[] getAllRDCs() {
		val list = new BasicEList<RDC>
		for (c : compartments)
			list.addAll(c.rdcs)
		return list
	}
	
	op Connector[] getAllConnectors() {
		val list = new BasicEList<Connector>
		for (r : allRDCs)
			list.addAll(r.connectors)
		return list
	}
	
	op HardwareElement[] getAllHardwareElements(int level) {
		if (level == 0) 		return allConnectors.map[it as HardwareElement]
		else if (level == 1)	return allRDCs.map[it as HardwareElement]
		else if (level == 2)	return compartments.map[it as HardwareElement]
		else return null
	}
	
}



class HardwareElement {
	 String name 			= ""
	 contains MetricParameter[0..*] metricParameters
}

class Compartment extends HardwareElement {
	String manufacturer	= ""
	String powerSupply		= ""
	String side				= ""
	String zone				= ""
	contains RDC[0..*] rdcs opposite compartment
	
	op String toString() 			{ name }
	
	op Connector[] getAllConnectors() {
		val list = new BasicEList<Connector>
		for (rdc : rdcs)
			list.addAll(rdc.connectors)		
		return list
	}
	
}

class RDC extends HardwareElement {
	String manufacturer	= ""
	String powerSupply		= ""
	String side				= ""
	String rdcType	 		= ""
	String ess				= ""
	container Compartment compartment opposite rdcs
	contains Connector[0..*] connectors opposite rdc
	op String toString() 			{ name }
}

class Connector extends HardwareElement {
	container RDC rdc opposite connectors
	contains AvailableEqInterface[0..*] 	availableEqInterfaces
	op String fullName() 					{ rdc.compartment.name + "." + rdc.name + "." + name }
	op String toString() 			{ name }
}

class AvailableEqInterface {
	String eqInterfaceType 	= ""
	int count 				= "0"
}

class EqInterfaceOrGroup {
	String name = ""
	op String toString() { name }
}

class EqInterface extends EqInterfaceOrGroup {
	String system		= ""
	String subAta		= ""
	String resource		= ""
	String lineName		= ""
	String wiringLane	= ""
	String grpInfo		= ""
	String route		= ""
	String pwSup1		= ""
	String emhZone1		= ""
	String ioType		= ""

	refers Connector[0..1] 	mappedConnector
	contains MetricParameter[0..*] metricParameters
	op String toString() { name }	
}

class EqInterfaceGroup extends EqInterfaceOrGroup {
	refers EqInterface[0..*] eqInterfaces
	contains ImplicitEqInterfaceGroupDefinition [0..*] implicitGroupDefinitions
	
	op String toString() { name }

	op EqInterface[] getImplicitlyDefinedEqInterfaces() {
		val list = new BasicEList<EqInterface>
		val model = this.eContainer as AssistModel
		
		// We have to explode all implicit group definitions
		for (implicitDefinitionElement : this.implicitGroupDefinitions) {
			
			// contains the interfaces discovered for a single implicit definition element
			var Iterable<EqInterface> interfaceList = model.eqInterfaces	
					
			// Go through all entries (they are concatenated by AND)
			for (entry : implicitDefinitionElement.entries) {
				switch (entry.attribute) {
					case NAME:			{ interfaceList = interfaceList.filter[it.name.equals(entry.value)			]}
					case SYSTEM: 		{ interfaceList = interfaceList.filter[it.system.equals(entry.value)		]}
					case SUBATA: 		{ interfaceList = interfaceList.filter[it.subAta.equals(entry.value)		]}
					case RESOURCE: 		{ interfaceList = interfaceList.filter[it.resource.equals(entry.value)		]}
					case LINENAME: 		{ interfaceList = interfaceList.filter[it.lineName.equals(entry.value)		]}
					case WIRINGLANE:	{ interfaceList = interfaceList.filter[it.wiringLane.equals(entry.value)	]}
					case GRPINFO: 		{ interfaceList = interfaceList.filter[it.grpInfo.equals(entry.value)		]}
					case ROUTE: 		{ interfaceList = interfaceList.filter[it.route.equals(entry.value)			]}
					case PWSUP1: 		{ interfaceList = interfaceList.filter[it.pwSup1.equals(entry.value)		]}
					case EMHZONE1: 		{ interfaceList = interfaceList.filter[it.emhZone1.equals(entry.value)		]}
					case IOTYPE: 		{ interfaceList = interfaceList.filter[it.ioType.equals(entry.value)		]}
				} // switch
			} // for (entry)
		
			list.addAll(interfaceList)
		
		} // for (implicit group definition elements)
		
		return (list.toSet.toList.toEList)
	}
}


class ImplicitEqInterfaceGroupDefinition {
	contains ImplicitEqInterfaceGroupDefinitionAttributesAndValues[1..*] entries
}


class ImplicitEqInterfaceGroupDefinitionAttributesAndValues {
	ImplicitEqInterfaceGroupDefinitionAttribute attribute
	String					 			value
}

enum ImplicitEqInterfaceGroupDefinitionAttribute {
	NAME		as 	"Name"
	SYSTEM 		as 	"InterfaceSystem"
	SUBATA		as 	"SubAta"
	RESOURCE	as 	"Resource"
	LINENAME	as 	"LineName"
	WIRINGLANE	as 	"WiringLane"
	GRPINFO		as 	"GrpInfo"
	ROUTE		as 	"Route"
	PWSUP1		as 	"PwSup1"
	EMHZONE1	as 	"EmhZone1"
	IOTYPE		as 	"IoType"
}

class EqInterfaceGroupWithCombinedDefinition extends EqInterfaceGroup {
	refers EqInterfaceGroup [1..*] combinedGroups
}


class MetricParameter {
	String name = ""
	int value = "0"
}


/*** RELATIONS  ****/

enum HardwareArchitectureLevelType {
	CONNECTOR 	as "Connector"
	RDC		  	as "RDC"
	COMPARTMENT as "Compartment"
}

class DislocalityRelation{
	refers EqInterfaceOrGroup[1..*] eqInterfaceOrGroups
	HardwareArchitectureLevelType hardwareLevel
	
	op EqInterface[] getAllInterfaces() {
		val list = new BasicEList<EqInterface>
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				list.add(e)
			else if (e instanceof EqInterfaceGroup) 	list.addAll(e.eqInterfaces)
		}

		return list
	}
	
	op int getTotalInterfaceCount() {
		var counter = 0
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				counter += 1
			else if (e instanceof EqInterfaceGroup) 	counter += e.eqInterfaces.length
		}
		
		return counter
	}
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
}

class ColocalityRelation {
	refers EqInterfaceOrGroup[1..*] eqInterfaceOrGroups
	HardwareArchitectureLevelType hardwareLevel
	
	op EqInterface[] getAllInterfaces() {
		val list = new BasicEList<EqInterface>
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				list.add(e)
			else if (e instanceof EqInterfaceGroup) 	list.addAll(e.eqInterfaces)
		}

		return list
	}
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
}


class DeploymentSpecification {
	refers EqInterfaceOrGroup[1..*] eqInterfaceOrGroups
	refers HardwareElement[0..*] hardwareElements
	contains DeploymentImplicitDefinition [1..*] implicitHardwareElements
	
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
	
	op Connector[] getImplicitlyDefinedConnectors() {
		val list = new BasicEList<Connector>
		val model = this.eContainer as AssistModel
		
		for (definition : this.implicitHardwareElements) {
			var Iterable<Connector> connectorList = model.allConnectors
	
			for (entry : definition.entries) {
				switch (entry.attribute) {
					case COMPARTMENT_NAME:			{ connectorList = connectorList.filter[it.rdc.compartment.name.equals(entry.value)			]}
					case COMPARTMENT_MANUFACTURER:	{ connectorList = connectorList.filter[it.rdc.compartment.manufacturer.equals(entry.value)	]}
					case COMPARTMENT_POWERSUPPLY:	{ connectorList = connectorList.filter[it.rdc.compartment.powerSupply.equals(entry.value)	]}
					case COMPARTMENT_SIDE:			{ connectorList = connectorList.filter[it.rdc.compartment.side.equals(entry.value)			]}
					case COMPARTMENT_ZONE:			{ connectorList = connectorList.filter[it.rdc.compartment.zone.equals(entry.value)			]}
					case RDC_NAME:					{ connectorList = connectorList.filter[it.rdc.name.equals(entry.value)						]}
					case RDC_MANUFACTURER: 			{ connectorList = connectorList.filter[it.rdc.manufacturer.equals(entry.value)				]}
					case RDC_POWERSUPPLY: 			{ connectorList = connectorList.filter[it.rdc.powerSupply.equals(entry.value)				]}
					case RDC_SIDE: 					{ connectorList = connectorList.filter[it.rdc.side.equals(entry.value)						]}
					case RDC_TYPE: 					{ connectorList = connectorList.filter[it.rdc.rdcType.equals(entry.value)					]}
					case RDC_ESS: 					{ connectorList = connectorList.filter[it.rdc.ess.equals(entry.value)						]}
					case CONNECTOR_NAME:			{ connectorList = connectorList.filter[it.name.equals(entry.value)							]}
				} // switch
			} // for (entry)
			
			list.addAll(connectorList)
			
		} // for (implicit definition)
	
		return (list.toSet.toList.toEList)
	}
}

class DeploymentImplicitDefinition {
	contains DeploymentImplicitDefinitionAttributeAndValue [1..*] entries
}

class DeploymentImplicitDefinitionAttributeAndValue {
	DeploymentImplicitDefinitionAttribute 	attribute
	String					 					value
}

enum DeploymentImplicitDefinitionAttribute {
	COMPARTMENT_NAME			as  "Compartment.Name"
	COMPARTMENT_MANUFACTURER 	as  "Compartment.Manufacturer"
	COMPARTMENT_POWERSUPPLY		as	"Compartment.PowerSupply"
	COMPARTMENT_SIDE			as	"Compartment.Side"
	COMPARTMENT_ZONE			as	"Compartment.Zone"

	RDC_NAME					as 	"RDC.Name"
	RDC_MANUFACTURER			as 	"RDC.Manufacturer"
	RDC_POWERSUPPLY				as 	"RDC.PowerSupply"
	RDC_SIDE					as 	"RDC.Side"
	RDC_TYPE					as 	"RDC.Type"
	RDC_ESS						as 	"RDC.ESS"

	CONNECTOR_NAME				as	"Connector.Name"
	
	
}

class ValidDeployment extends DeploymentSpecification {}

class InvalidDeployment extends DeploymentSpecification {}

