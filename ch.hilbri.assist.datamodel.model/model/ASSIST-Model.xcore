@GenModel(
	modelPluginID="ch.hilbri.assist.datamodel.model",
	editDirectory="/ch.hilbri.assist.datamodel.model.edit/src", 
	editPluginID="ch.hilbri.assist.datamodel.model.edit",
	editorDirectory="/ch.hilbri.assist.datamodel.model.editor/src", 
	editorPluginID="ch.hilbri.assist.datamodel.model.editor",
	generateModelWizard="false", 
	generateExampleClass="false" 
 )

package ch.hilbri.assist.datamodel.model

import org.eclipse.emf.common.util.BasicEList


annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

class AssistModel {
	String 									systemName 	= ""

	contains Compartment[0..*]				compartments
	contains EqInterface[0..*]				eqInterfaces
	contains EqInterfaceGroup[0..*]			eqInterfaceGroups
	contains DislocalityRelation[0..*]		dislocalityRelations
	contains ColocalityRelation[0..*]		colocalityRelations
	contains ValidDeployment[0..*]			validDeployments
	contains InvalidDeployment[0..*]		invalidDeployments

	
	op Compartment[] getAllCompartments() {
		return compartments
	}
	
	op RDC[] getAllRDCs() {
		val list = new BasicEList<RDC>
		for (c : compartments)
			list.addAll(c.rdcs)
		return list
	}
	
	op Connector[] getAllConnectors() {
		val list = new BasicEList<Connector>
		for (r : allRDCs)
			list.addAll(r.connectors)
		return list
	}
	
	op HardwareElement[] getAllHardwareElements(int level) {
		if (level == 0) 		return allConnectors.map[it as HardwareElement]
		else if (level == 1)	return allRDCs.map[it as HardwareElement]
		else if (level == 2)	return compartments.map[it as HardwareElement]
		else return null
	}
	
}



class HardwareElement {
	 String name 			= ""
	 contains MetricParameter[0..*] metricParameters
}

class Compartment extends HardwareElement {
	String manufacturer	= ""
	String powerSupply		= ""
	String side				= ""
	String zone				= ""
	contains RDC[0..*] rdcs opposite compartment
	
	op String toString() 			{ name }
	
	op Connector[] getAllConnectors() {
		val list = new BasicEList<Connector>
		for (rdc : rdcs)
			list.addAll(rdc.connectors)		
		return list
	}
	
}

class RDC extends HardwareElement {
	String manufacturer		= ""
	String powerSupply		= ""
	String side				= ""
	String rdcType	 		= ""
	String ess				= ""
	String resourceX		= ""
	String resourceY		= ""
	String resourceZ		= ""
	container Compartment compartment opposite rdcs
	contains Connector[0..*] connectors opposite rdc
	op String toString() 			{ name }
}

class Connector extends HardwareElement {
	container RDC rdc opposite connectors
	contains AvailableEqInterface[0..*] 	availableEqInterfaces
	op String fullName() 					{ rdc.compartment.name + "." + rdc.name + "." + name }
	op String toString() 			{ name }
}

class AvailableEqInterface {
	String eqInterfaceType 	= ""
	int count 				= "0"
}

class EqInterfaceOrGroup {
	String name = ""
	op String toString() { name }
}

class EqInterface extends EqInterfaceOrGroup {
	String system		= ""
	String subAta		= ""
	String lineName		= ""
	String wiringLane	= ""
	String grpInfo		= ""
	String route		= ""
	String pwSup1		= ""
	String emhZone1		= ""
	String ioType		= ""
	String resource		= ""
	String resourceX	= ""
	String resourceY	= ""
	String resourceZ	= ""
	contains MetricParameter[0..*] metricParameters
	op String toString() { name }	
}

class EqInterfaceGroup extends EqInterfaceOrGroup {
	refers EqInterface[0..*] eqInterfaces
	contains ImplicitEqInterfaceMemberDefinition [0..*] implicitMemberDefinitions
	
	op String toString() { name }

	op EqInterface[] getImplicitlyDefinedEqInterfaces() {
		val list = new BasicEList<EqInterface>
		
		// We have to explode all implicit group definitions
		for (implicitDefinitionElement : this.implicitMemberDefinitions) {
			list.addAll(implicitDefinitionElement.implicitlyDefinedEqInterfaces)
		} 
		
		return (list.toSet.toList.toEList)
	}
}


class ImplicitEqInterfaceMemberDefinition {
	contains ImplicitEqInterfaceMemberDefinitionAttributesAndValues[1..*] entries

	op EqInterface[] getImplicitlyDefinedEqInterfaces() {
		val list = new BasicEList<EqInterface>
		val model = this.eContainer.eContainer as AssistModel
		
		// contains the interfaces discovered for a single implicit definition element
		var Iterable<EqInterface> interfaceList = model.eqInterfaces	
					
		// Go through all entries (they are concatenated by AND)
		for (entry : entries) {
			switch (entry.attribute) {
				case NAME:			{ interfaceList = interfaceList.filter[it.name.equals(entry.value)			]}
				case SYSTEM: 		{ interfaceList = interfaceList.filter[it.system.equals(entry.value)		]}
				case SUBATA: 		{ interfaceList = interfaceList.filter[it.subAta.equals(entry.value)		]}
				case RESOURCE: 		{ interfaceList = interfaceList.filter[it.resource.equals(entry.value)		]}
				case LINENAME: 		{ interfaceList = interfaceList.filter[it.lineName.equals(entry.value)		]}
				case WIRINGLANE:	{ interfaceList = interfaceList.filter[it.wiringLane.equals(entry.value)	]}
				case GRPINFO: 		{ interfaceList = interfaceList.filter[it.grpInfo.equals(entry.value)		]}
				case ROUTE: 		{ interfaceList = interfaceList.filter[it.route.equals(entry.value)			]}
				case PWSUP1: 		{ interfaceList = interfaceList.filter[it.pwSup1.equals(entry.value)		]}
				case EMHZONE1: 		{ interfaceList = interfaceList.filter[it.emhZone1.equals(entry.value)		]}
				case IOTYPE: 		{ interfaceList = interfaceList.filter[it.ioType.equals(entry.value)		]}
				case RESOURCE_X: 	{ interfaceList = interfaceList.filter[it.resourceX.equals(entry.value)		]}
				case RESOURCE_Y: 	{ interfaceList = interfaceList.filter[it.resourceY.equals(entry.value)		]}
				case RESOURCE_Z: 	{ interfaceList = interfaceList.filter[it.resourceZ.equals(entry.value)		]}
			} // switch
		} // for (entry)
		
		list.addAll(interfaceList)
		
		return (list.toSet.toList.toEList)
	}
}


class ImplicitEqInterfaceMemberDefinitionAttributesAndValues {
	ImplicitEqInterfaceMemberDefinitionAttribute attribute
	String					 			value
}

enum ImplicitEqInterfaceMemberDefinitionAttribute {
	NAME		as 	"Name"
	SYSTEM 		as 	"InterfaceSystem"
	SUBATA		as 	"SubAta"
	RESOURCE	as 	"Resource"
	LINENAME	as 	"LineName"
	WIRINGLANE	as 	"WiringLane"
	GRPINFO		as 	"GrpInfo"
	ROUTE		as 	"Route"
	PWSUP1		as 	"PwSup1"
	EMHZONE1	as 	"EmhZone1"
	IOTYPE		as 	"IoType"
	RESOURCE_X	as	"ResourceX"
	RESOURCE_Y	as	"ResourceY"
	RESOURCE_Z	as	"ResourceZ"
}

class EqInterfaceGroupWithCombinedDefinition extends EqInterfaceGroup {
	refers EqInterfaceGroup [1..*] combinedGroups
}


class MetricParameter {
	String name = ""
	int value = "0"
}


/*** RELATIONS  ****/

enum HardwareArchitectureLevelType {
	CONNECTOR 	as "Connector"
	RDC		  	as "RDC"
	COMPARTMENT as "Compartment"
}

class DislocalityRelation{
	refers EqInterfaceOrGroup[1..*] eqInterfaceOrGroups
	HardwareArchitectureLevelType hardwareLevel
	
	op EqInterface[] getAllInterfaces() {
		val list = new BasicEList<EqInterface>
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				list.add(e)
			else if (e instanceof EqInterfaceGroup) 	list.addAll(e.eqInterfaces)
		}

		return list
	}
	
	op int getTotalInterfaceCount() {
		var counter = 0
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				counter += 1
			else if (e instanceof EqInterfaceGroup) 	counter += e.eqInterfaces.length
		}
		
		return counter
	}
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
}

class ColocalityRelation {
	refers EqInterfaceOrGroup[1..*] eqInterfaceOrGroups
	HardwareArchitectureLevelType hardwareLevel
	
	op EqInterface[] getAllInterfaces() {
		val list = new BasicEList<EqInterface>
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				list.add(e)
			else if (e instanceof EqInterfaceGroup) 	list.addAll(e.eqInterfaces)
		}

		return list
	}
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
}


class DeploymentSpecification {
	refers EqInterfaceOrGroup[1..*] 				eqInterfaceOrGroups
	refers HardwareElement[0..*] 					hardwareElements
	contains DeploymentImplicitDefinition[0..*] 	implicitHardwareElements
	
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
	
	op Connector[] getImplicitlyDefinedConnectors() {
		val list = new BasicEList<Connector>
		
		for (definition : this.implicitHardwareElements) {
			list.addAll(definition.implicitlyDefinedConnectors)
		} // for (implicit definition)
	
		return (list.toSet.toList.toEList)
	}
}

class DeploymentImplicitDefinition {
	contains DeploymentImplicitDefinitionAttributeAndValue [1..*] entries

	op Connector[] getImplicitlyDefinedConnectors() {
		val list = new BasicEList<Connector>
		val model = this.eContainer.eContainer as AssistModel
		var Iterable<Connector> connectorList = model.allConnectors
	
		for (entry : entries) {
			switch (entry.attribute) {
				case COMPARTMENT_NAME:			{ connectorList = connectorList.filter[it.rdc.compartment.name.equals(entry.value)			]}
				case COMPARTMENT_MANUFACTURER:	{ connectorList = connectorList.filter[it.rdc.compartment.manufacturer.equals(entry.value)	]}
				case COMPARTMENT_POWERSUPPLY:	{ connectorList = connectorList.filter[it.rdc.compartment.powerSupply.equals(entry.value)	]}
				case COMPARTMENT_SIDE:			{ connectorList = connectorList.filter[it.rdc.compartment.side.equals(entry.value)			]}
				case COMPARTMENT_ZONE:			{ connectorList = connectorList.filter[it.rdc.compartment.zone.equals(entry.value)			]}
				
				case RDC_NAME:					{ connectorList = connectorList.filter[it.rdc.name.equals(entry.value)						]}
				case RDC_MANUFACTURER: 			{ connectorList = connectorList.filter[it.rdc.manufacturer.equals(entry.value)				]}
				case RDC_POWERSUPPLY: 			{ connectorList = connectorList.filter[it.rdc.powerSupply.equals(entry.value)				]}
				case RDC_SIDE: 					{ connectorList = connectorList.filter[it.rdc.side.equals(entry.value)						]}
				case RDC_TYPE: 					{ connectorList = connectorList.filter[it.rdc.rdcType.equals(entry.value)					]}
				case RDC_ESS: 					{ connectorList = connectorList.filter[it.rdc.ess.equals(entry.value)						]}
				case RDC_RESOURCE_X:			{ connectorList = connectorList.filter[it.rdc.resourceX.equals(entry.value)					]}
				case RDC_RESOURCE_Y:			{ connectorList = connectorList.filter[it.rdc.resourceY.equals(entry.value)					]}
				case RDC_RESOURCE_Z:			{ connectorList = connectorList.filter[it.rdc.resourceZ.equals(entry.value)					]}
				
				case CONNECTOR_NAME:			{ connectorList = connectorList.filter[it.name.equals(entry.value)							]}
			} // switch
		} // for (entry)
			
		list.addAll(connectorList)
				
		return (list.toSet.toList.toEList)
	}
}

class DeploymentImplicitDefinitionAttributeAndValue {
	DeploymentImplicitDefinitionAttribute 	attribute
	String					 					value
}

enum DeploymentImplicitDefinitionAttribute {
	COMPARTMENT_NAME			as  "Compartment.Name"
	COMPARTMENT_MANUFACTURER 	as  "Compartment.Manufacturer"
	COMPARTMENT_POWERSUPPLY		as	"Compartment.PowerSupply"
	COMPARTMENT_SIDE			as	"Compartment.Side"
	COMPARTMENT_ZONE			as	"Compartment.Zone"

	RDC_NAME					as 	"RDC.Name"
	RDC_MANUFACTURER			as 	"RDC.Manufacturer"
	RDC_POWERSUPPLY				as 	"RDC.PowerSupply"
	RDC_SIDE					as 	"RDC.Side"
	RDC_TYPE					as 	"RDC.Type"
	RDC_ESS						as 	"RDC.ESS"
	RDC_RESOURCE_X				as  "RDC.ResourceX"
	RDC_RESOURCE_Y				as  "RDC.ResourceY"
	RDC_RESOURCE_Z				as  "RDC.ResourceZ"

	CONNECTOR_NAME				as	"Connector.Name"
	
	
}

class ValidDeployment extends DeploymentSpecification {}

class InvalidDeployment extends DeploymentSpecification {}

