@GenModel(
	modelPluginID="ch.hilbri.assist.datamodel.model",
	editDirectory="/ch.hilbri.assist.datamodel.model.edit/src", 
	editPluginID="ch.hilbri.assist.datamodel.model.edit",
	editorDirectory="/ch.hilbri.assist.datamodel.model.editor/src", 
	editorPluginID="ch.hilbri.assist.datamodel.model.editor",
	generateModelWizard="false", 
	generateExampleClass="false" 
 )

package ch.hilbri.assist.datamodel.model

import org.eclipse.emf.common.util.BasicEList

annotation "http://www.eclipse.org/emf/2002/GenModel" as GenModel

class AssistModel {
	
	contains GlobalBlock[1]					globalBlock
	contains CompartmentsBlock[1]			compartmentsBlock
	contains InterfacesBlock[1]				interfacesBlock
	contains InterfaceGroupsBlock[0..1]		interfaceGroupsBlock
	contains RestrictionsBlock[0..1]		restrictionsBlock
	
	// Methods
	op String					getSystemName()				{ globalBlock.systemName										}
	op CompatibleIoTypeEntry[] 	getCompatibleIoTypes() 		{ globalBlock.compatibleIoTypesBlock?.compatibleIoTypes			}
	op CableWeightEntry[]  		getCableWeightData() 		{ globalBlock.cableWeightDataBlock?.cableWeightEntries   		}
	op ProtectionLevelEntry[] 	getProtectionLevelData()	{ globalBlock.protectionLevelDataBlock?.protectionLevelEntries 	}
	op Compartment[] 			getCompartments() 			{ compartmentsBlock.compartments 								}
	op RDC[] 					getRDCs() 					{ compartments.map[rdcs].flatten.toEList 						}
	op Connector[] 				getConnectors() 			{ RDCs.map[connectors].flatten.toEList							}
	op Pin[]					getPins()					{ connectors.map[pins].flatten.toEList 							}
	op EqInterface[]			getEqInterfaces()			{ interfacesBlock.eqInterfaces 									}
	op EqInterfaceGroup[]		getEqInterfaceGroups()		{ interfaceGroupsBlock?.eqInterfaceGroups 						}
	op ColocalityRelation[]		getColocalityRelations()	{ restrictionsBlock?.colocalityRelations 						}
	op DislocalityRelation[]	getDislocalityRelations()	{ restrictionsBlock?.dislocalityRelations						}
	op ValidDeployment[]		getValidDeployments()		{ restrictionsBlock?.validDeployments 							}
	op InvalidDeployment[]		getInvalidDeployments()		{ restrictionsBlock?.invalidDeployments 						}
	op String[]					getEqInterfaceTypes()		{ eqInterfaces.map[ioType].toSet.toEList						}
	
	op HardwareElement[] getAllHardwareElements(int level) {
		if (level == 0) 		return connectors.map[it as HardwareElement]
		else if (level == 1)	return RDCs.map[it as HardwareElement]
		else if (level == 2)	return compartments.map[it as HardwareElement]
		else return null
	}
	
	
}

/* *******************************************************************************
 * GLOBAL BLOCK
 * ******************************************************************************* */
   
class GlobalBlock {
	String 									systemName 				= ""
	contains CompatibleIoTypesBlock			compatibleIoTypesBlock
	contains CableWeightDataBlock			cableWeightDataBlock
	contains ProtectionLevelDataBlock		protectionLevelDataBlock
}

class CompatibleIoTypesBlock {
	contains CompatibleIoTypeEntry[0..*] 	compatibleIoTypes
}

class CompatibleIoTypeEntry {
	String 			eqInterfaceIoType 		= ""
	String[1..*] 	pinInterfaceIoTypes		= ""
}

class CableWeightDataBlock {
	contains CableWeightEntry[0..*] 		cableWeightEntries
	
	op double getDefaultCableWeight() {
		if (cableWeightEntries.filter[isDefaultEntry].empty) return 0
		else return cableWeightEntries.filter[isDefaultEntry].get(0).weight
	}
	
	op double getCableWeight(String ioType) {
		if (cableWeightEntries.filter[eqInterfaceIoType.equals(ioType)].isEmpty) return defaultCableWeight
		else return cableWeightEntries.filter[eqInterfaceIoType.equals(ioType)].get(0).weight 
	}
}

class CableWeightEntry {
	boolean			defaultEntry			= "false"
	String			eqInterfaceIoType		= ""
	double 			weight					= "0.0"
}

class ProtectionLevelDataBlock {
	contains ProtectionLevelEntry[0..*]		protectionLevelEntries
}

class ProtectionLevelEntry{
	String 						rdcLocation		= ""
	String 						emhZone1		= ""
	ProtectionLevelType[1..*] 	protectionLevel
}

/* *******************************************************************************
 * COMPARTMENTS BLOCK
 * ******************************************************************************* */

class CompartmentsBlock {
	contains Compartment[*]		compartments
}

class HardwareElement {
	String name 							= ""
	contains MetricParametersBlock[0..1]	metricParametersBlock
}

class MetricParametersBlock {
	 contains MetricParameter[*] metricParameters
}

class MetricParameter {
	String name = ""
	int value = "0"
}

class Compartment extends HardwareElement {
	String manufacturer		= ""
	String powerSupply		= ""
	String side				= ""
	String zone				= ""
	
	contains RDC[0..*] rdcs opposite compartment
	
	op String toString() 				{ name }
	op Connector[] getAllConnectors() 	{ rdcs.map[connectors].flatten.toEList }
}

class RDC extends HardwareElement {
	String manufacturer		= ""
	String powerSupply1		= ""
	String powerSupply2		= ""
	String side				= ""
	String rdcType	 		= ""
	String ess				= ""
	String location			= ""
	int resourceX			= "0"
	int resourceY			= "0"
	int resourceZ			= "0"
	container Compartment 						compartment opposite rdcs
	contains Connector[*] 						connectors opposite rdc
	contains InternalConnectedPinBlock[0..1] 	internalConnectedPinBlock
	op String toString() 			{ name }
}

class InternalConnectedPinBlock {
	contains ConnectedPinEntry[*] connectedPins
}

class ConnectedPinEntry {
	refers Pin[2..*]	pins
}

class Connector extends HardwareElement {
	container 	RDC 	rdc 	opposite connectors
	contains 	Pin[*] 	pins 	opposite connector

	op String fullName() 					{ rdc.compartment.name + "." + rdc.name + "." + name }
	op String toString() 					{ name }
}

class Pin extends HardwareElement {
	container Connector connector 		opposite pins
	String 				eqInterfaceType = ""
	ProtectionLevelType protectionLevel = "None"

	op String toString() 					{ name }
}



enum ProtectionLevelType {
	NONE 	as "None"
	L1 		as "L1"
	L2 		as "L2"
	L3 		as "L3"
	L4 		as "L4"
	L5 		as "L5"
	L6 		as "L6"
	L7 		as "L7"
	L8 		as "L8"
}

/* *******************************************************************************
 * INTERFACES BLOCK
 * ******************************************************************************* */
class InterfacesBlock {
	contains EqInterface[0..*]				eqInterfaces
}

class EqInterfaceOrGroup {
	String name = ""
	op String toString() { name }
}

class EqInterface extends EqInterfaceOrGroup {
	String system		= ""
	String subAta		= ""
	String lineName		= ""
	String wiringLane	= ""
	String grpInfo		= ""
	String route		= ""
	String pwSup1		= ""
	String emhZone1		= ""
	String ioType		= ""
	String resource		= ""
	int resourceX		= "0"
	int resourceY		= "0"
	int resourceZ		= "0"
	contains MetricParameter[0..*] metricParameters
	op String toString() { name }	
}

/* *******************************************************************************
 * INTERFACE GROUPS BLOCK
 * ******************************************************************************* */
class InterfaceGroupsBlock {
	contains EqInterfaceGroup[0..*]			eqInterfaceGroups
}

class EqInterfaceGroup extends EqInterfaceOrGroup {
	refers EqInterface[0..*] eqInterfaces
	refers EqInterface[0..*] withoutEqInterfaces
	
	contains ImplicitEqInterfaceMemberDefinition [0..*] implicitMemberDefinitions
	contains ImplicitEqInterfaceMemberDefinition [0..*] withoutImplicitMemberDefinitions
	
	op String toString() { name }

	op EqInterface[] getImplicitlyDefinedEqInterfaces() {
		val list = new BasicEList<EqInterface>
		
		// We have to explode all implicit group definitions
		for (implicitDefinitionElement : this.implicitMemberDefinitions) {
			list.addAll(implicitDefinitionElement.implicitlyDefinedEqInterfaces)
		} 
		
		return (list.toSet.toList.toEList)
	}
	
	op EqInterface[] getWithoutImplicitlyDefinedEqInterfaces() {
		val list = new BasicEList<EqInterface>
		
		// We have to explode all implicit group definitions
		for (implicitDefinitionElement : this.withoutImplicitMemberDefinitions) {
			list.addAll(implicitDefinitionElement.implicitlyDefinedEqInterfaces)
		} 
		
		return (list.toSet.toList.toEList)
	}
}


class ImplicitEqInterfaceMemberDefinition {
	contains ImplicitEqInterfaceMemberDefinitionAttributesAndValues[1..*] entries

	op EqInterface[] getImplicitlyDefinedEqInterfaces() {
		val list = new BasicEList<EqInterface>
		val model = this.eContainer.eContainer as AssistModel
		
		// contains the interfaces discovered for a single implicit definition element
		var Iterable<EqInterface> interfaceList = model.interfacesBlock.eqInterfaces	
					
		// Go through all entries (they are concatenated by AND)
		for (entry : entries) {
			switch (entry.attribute) {
				case NAME:			{ interfaceList = interfaceList.filter[it.name.equals(entry.value)			]}
				case SYSTEM: 		{ interfaceList = interfaceList.filter[it.system.equals(entry.value)		]}
				case SUBATA: 		{ interfaceList = interfaceList.filter[it.subAta.equals(entry.value)		]}
				case RESOURCE: 		{ interfaceList = interfaceList.filter[it.resource.equals(entry.value)		]}
				case LINENAME: 		{ interfaceList = interfaceList.filter[it.lineName.equals(entry.value)		]}
				case WIRINGLANE:	{ interfaceList = interfaceList.filter[it.wiringLane.equals(entry.value)	]}
				case GRPINFO: 		{ interfaceList = interfaceList.filter[it.grpInfo.equals(entry.value)		]}
				case ROUTE: 		{ interfaceList = interfaceList.filter[it.route.equals(entry.value)			]}
				case PWSUP1: 		{ interfaceList = interfaceList.filter[it.pwSup1.equals(entry.value)		]}
				case EMHZONE1: 		{ interfaceList = interfaceList.filter[it.emhZone1.equals(entry.value)		]}
				case IOTYPE: 		{ interfaceList = interfaceList.filter[it.ioType.equals(entry.value)		]}
				case RESOURCE_X: 	{ interfaceList = interfaceList.filter[it.resourceX.equals(entry.value)		]}
				case RESOURCE_Y: 	{ interfaceList = interfaceList.filter[it.resourceY.equals(entry.value)		]}
				case RESOURCE_Z: 	{ interfaceList = interfaceList.filter[it.resourceZ.equals(entry.value)		]}
			} // switch
		} // for (entry)
		
		list.addAll(interfaceList)
		
		return (list.toSet.toList.toEList)
	}
}


class ImplicitEqInterfaceMemberDefinitionAttributesAndValues {
	ImplicitEqInterfaceMemberDefinitionAttribute attribute
	String					 			value
}

enum ImplicitEqInterfaceMemberDefinitionAttribute {
	NAME		as 	"Name"
	SYSTEM 		as 	"InterfaceSystem"
	SUBATA		as 	"SubAta"
	RESOURCE	as 	"Resource"
	LINENAME	as 	"LineName"
	WIRINGLANE	as 	"WiringLane"
	GRPINFO		as 	"GrpInfo"
	ROUTE		as 	"Route"
	PWSUP1		as 	"PwSup1"
	EMHZONE1	as 	"EmhZone1"
	IOTYPE		as 	"IoType"
	RESOURCE_X	as	"ResourceX"
	RESOURCE_Y	as	"ResourceY"
	RESOURCE_Z	as	"ResourceZ"
}

class EqInterfaceGroupWithCombinedDefinition extends EqInterfaceGroup {
	refers EqInterfaceGroup [1..*] combinedGroups
}


/* *******************************************************************************
 * RESTRICTIONS BLOCK
 * ******************************************************************************* */
class RestrictionsBlock {
	contains DislocalityRelation[0..*]		dislocalityRelations
	contains ColocalityRelation[0..*]		colocalityRelations
	contains ValidDeployment[0..*]			validDeployments
	contains InvalidDeployment[0..*]		invalidDeployments
}


enum HardwareArchitectureLevelType {
	PIN			as "Pin"
	CONNECTOR 	as "Connector"
	RDC		  	as "RDC"
	COMPARTMENT as "Compartment"
}

class DislocalityRelation{
	refers EqInterfaceOrGroup[1..*] eqInterfaceOrGroups
	HardwareArchitectureLevelType hardwareLevel
	
	op EqInterface[] getAllInterfaces() {
		val list = new BasicEList<EqInterface>
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				list.add(e)
			else if (e instanceof EqInterfaceGroup) 	list.addAll(e.eqInterfaces)
		}

		return list
	}
	
	op int getTotalInterfaceCount() {
		var counter = 0
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				counter += 1
			else if (e instanceof EqInterfaceGroup) 	counter += e.eqInterfaces.length
		}
		
		return counter
	}
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
}

class ColocalityRelation {
	refers EqInterfaceOrGroup[1..*] eqInterfaceOrGroups
	HardwareArchitectureLevelType hardwareLevel
	
	op EqInterface[] getAllInterfaces() {
		val list = new BasicEList<EqInterface>
		
		for (e : eqInterfaceOrGroups) {
			if (e instanceof EqInterface) 				list.add(e)
			else if (e instanceof EqInterfaceGroup) 	list.addAll(e.eqInterfaces)
		}

		return list
	}
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
}


class DeploymentSpecification {
	refers EqInterfaceOrGroup[1..*] 				eqInterfaceOrGroups
	refers HardwareElement[0..*] 					hardwareElements
	contains DeploymentImplicitDefinition[0..*] 	implicitHardwareElements
	
	
	op String getAllEqInterfaceOrGroupNames() {
		var String result = ""
		var boolean first = true
		
		for (e : eqInterfaceOrGroups) {
			if (!first) result += ", "
			else first = false
			
			if (e instanceof EqInterface) 		result += e.name
			if (e instanceof EqInterfaceGroup) 	result += e.name
		}	
		
		return result
	}
	
	op Connector[] getImplicitlyDefinedConnectors() {
		val list = new BasicEList<Connector>
		
		for (definition : this.implicitHardwareElements) {
			list.addAll(definition.implicitlyDefinedConnectors)
		} // for (implicit definition)
	
		return (list.toSet.toList.toEList)
	}
}

class DeploymentImplicitDefinition {
	contains DeploymentImplicitDefinitionAttributeAndValue [1..*] entries

	op Connector[] getImplicitlyDefinedConnectors() {
		val list = new BasicEList<Connector>
		val model = this.eContainer.eContainer as AssistModel
		var Iterable<Connector> connectorList = model.connectors
	
		for (entry : entries) {
			switch (entry.attribute) {
				case COMPARTMENT_NAME:			{ connectorList = connectorList.filter[it.rdc.compartment.name.equals(entry.value)			]}
				case COMPARTMENT_MANUFACTURER:	{ connectorList = connectorList.filter[it.rdc.compartment.manufacturer.equals(entry.value)	]}
				case COMPARTMENT_POWERSUPPLY:	{ connectorList = connectorList.filter[it.rdc.compartment.powerSupply.equals(entry.value)	]}
				case COMPARTMENT_SIDE:			{ connectorList = connectorList.filter[it.rdc.compartment.side.equals(entry.value)			]}
				case COMPARTMENT_ZONE:			{ connectorList = connectorList.filter[it.rdc.compartment.zone.equals(entry.value)			]}
				
				case RDC_NAME:					{ connectorList = connectorList.filter[it.rdc.name.equals(entry.value)						]}
				case RDC_MANUFACTURER: 			{ connectorList = connectorList.filter[it.rdc.manufacturer.equals(entry.value)				]}
				case RDC_POWERSUPPLY1: 			{ connectorList = connectorList.filter[it.rdc.powerSupply1.equals(entry.value)				]}
				case RDC_POWERSUPPLY2: 			{ connectorList = connectorList.filter[it.rdc.powerSupply2.equals(entry.value)				]}
				case RDC_SIDE: 					{ connectorList = connectorList.filter[it.rdc.side.equals(entry.value)						]}
				case RDC_TYPE: 					{ connectorList = connectorList.filter[it.rdc.rdcType.equals(entry.value)					]}
				case RDC_ESS: 					{ connectorList = connectorList.filter[it.rdc.ess.equals(entry.value)						]}
				case RDC_RESOURCE_X:			{ connectorList = connectorList.filter[it.rdc.resourceX.equals(entry.value)					]}
				case RDC_RESOURCE_Y:			{ connectorList = connectorList.filter[it.rdc.resourceY.equals(entry.value)					]}
				case RDC_RESOURCE_Z:			{ connectorList = connectorList.filter[it.rdc.resourceZ.equals(entry.value)					]}
				
				case CONNECTOR_NAME:			{ connectorList = connectorList.filter[it.name.equals(entry.value)							]}
			} // switch
		} // for (entry)
			
		list.addAll(connectorList)
				
		return (list.toSet.toList.toEList)
	}
}

class DeploymentImplicitDefinitionAttributeAndValue {
	DeploymentImplicitDefinitionAttribute 	attribute
	String					 					value
}

enum DeploymentImplicitDefinitionAttribute {
	COMPARTMENT_NAME			as  "Compartment.Name"
	COMPARTMENT_MANUFACTURER 	as  "Compartment.Manufacturer"
	COMPARTMENT_POWERSUPPLY		as	"Compartment.PowerSupply"
	COMPARTMENT_SIDE			as	"Compartment.Side"
	COMPARTMENT_ZONE			as	"Compartment.Zone"

	RDC_NAME					as 	"RDC.Name"
	RDC_MANUFACTURER			as 	"RDC.Manufacturer"
	RDC_POWERSUPPLY1			as 	"RDC.PowerSupply1"
	RDC_POWERSUPPLY2			as 	"RDC.PowerSupply2"
	RDC_SIDE					as 	"RDC.Side"
	RDC_TYPE					as 	"RDC.Type"
	RDC_ESS						as 	"RDC.ESS"
	RDC_RESOURCE_X				as  "RDC.ResourceX"
	RDC_RESOURCE_Y				as  "RDC.ResourceY"
	RDC_RESOURCE_Z				as  "RDC.ResourceZ"

	CONNECTOR_NAME				as	"Connector.Name"
	
	
}

class ValidDeployment extends DeploymentSpecification {}

class InvalidDeployment extends DeploymentSpecification {}

